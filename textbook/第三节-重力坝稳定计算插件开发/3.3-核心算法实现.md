# 3.3 核心算法实现

## 3.3.1 几何参数提取

### 二维剖面几何分析器

几何参数提取是稳定性计算的基础，需要从复杂的三维坝体模型中准确提取计算所需的几何参数。

```csharp
namespace GravityDamAnalysis.Calculation.Geometry
{
    /// <summary>
    /// 二维剖面几何分析器
    /// 从剖面轮廓点计算几何特性
    /// </summary>
    public class Profile2DGeometryAnalyzer : IGeometryAnalyzer
    {
        private readonly ILogger<Profile2DGeometryAnalyzer> _logger;
        
        public Profile2DGeometryAnalyzer(ILogger<Profile2DGeometryAnalyzer> logger)
        {
            _logger = logger;
        }
        
        /// <summary>
        /// 分析二维剖面几何特性
        /// </summary>
        public async Task<Profile2DGeometryProperties> AnalyzeGeometryAsync(Profile2D profile)
        {
            _logger.LogDebug("开始分析剖面 {Index} 的几何特性", profile.Index);
            
            var points = profile.ProfilePoints;
            if (points.Count < 3)
                throw new ArgumentException("剖面点数量不足，至少需要3个点");
            
            // 确保轮廓闭合
            var closedPoints = EnsureClosedContour(points);
            
            // 提取关键点
            var keyPoints = ExtractKeyPoints(closedPoints);
            
            // 计算几何属性
            var properties = new Profile2DGeometryProperties
            {
                // 基本尺寸
                Height = CalculateHeight(keyPoints),
                BaseWidth = CalculateBaseWidth(keyPoints),
                TopWidth = CalculateTopWidth(keyPoints),
                
                // 面积和重心
                Area = CalculateArea(closedPoints),
                Centroid = CalculateCentroid(closedPoints),
                
                // 惯性矩
                MomentOfInertia = CalculateMomentOfInertia(closedPoints),
                
                // 坡度信息
                UpstreamSlope = CalculateUpstreamSlope(keyPoints),
                DownstreamSlope = CalculateDownstreamSlope(keyPoints),
                
                // 关键点位置
                CrestCenterPoint = keyPoints.CrestCenter,
                BaseCenterPoint = keyPoints.BaseCenter,
                UpstreamToePoint = keyPoints.UpstreamToe,
                DownstreamToePoint = keyPoints.DownstreamToe
            };
            
            _logger.LogDebug("剖面几何分析完成 - 高度: {Height:F2}m, 底宽: {BaseWidth:F2}m, " +
                "面积: {Area:F2}m²", properties.Height, properties.BaseWidth, properties.Area);
            
            return properties;
        }
        
        /// <summary>
        /// 确保轮廓闭合
        /// </summary>
        private List<Point2D> EnsureClosedContour(List<Point2D> points)
        {
            var result = new List<Point2D>(points);
            
            // 检查首尾点是否重合
            var first = result.First();
            var last = result.Last();
            
            if (Math.Abs(first.X - last.X) > 1e-6 || Math.Abs(first.Y - last.Y) > 1e-6)
            {
                result.Add(first); // 添加首点以闭合轮廓
            }
            
            return result;
        }
        
        /// <summary>
        /// 提取关键点位置
        /// </summary>
        private DamKeyPoints ExtractKeyPoints(List<Point2D> points)
        {
            // 找到最高点和最低点
            var maxY = points.Max(p => p.Y);
            var minY = points.Min(p => p.Y);
            
            // 找到坝顶中心点（最高处的中点）
            var topPoints = points.Where(p => Math.Abs(p.Y - maxY) < 0.1).ToList();
            var crestCenter = new Point2D(
                topPoints.Average(p => p.X),
                topPoints.Average(p => p.Y));
            
            // 找到坝底中心点
            var bottomPoints = points.Where(p => Math.Abs(p.Y - minY) < 0.1).ToList();
            var baseCenter = new Point2D(
                bottomPoints.Average(p => p.X),
                bottomPoints.Average(p => p.Y));
            
            // 找到上游趾点（左下角）
            var upstreamToe = bottomPoints.OrderBy(p => p.X).First();
            
            // 找到下游趾点（右下角）
            var downstreamToe = bottomPoints.OrderByDescending(p => p.X).First();
            
            return new DamKeyPoints
            {
                CrestCenter = crestCenter,
                BaseCenter = baseCenter,
                UpstreamToe = upstreamToe,
                DownstreamToe = downstreamToe
            };
        }
        
        /// <summary>
        /// 计算坝高
        /// </summary>
        private double CalculateHeight(DamKeyPoints keyPoints)
        {
            return keyPoints.CrestCenter.Y - keyPoints.BaseCenter.Y;
        }
        
        /// <summary>
        /// 计算坝底宽
        /// </summary>
        private double CalculateBaseWidth(DamKeyPoints keyPoints)
        {
            return keyPoints.DownstreamToe.X - keyPoints.UpstreamToe.X;
        }
        
        /// <summary>
        /// 计算坝顶宽
        /// </summary>
        private double CalculateTopWidth(DamKeyPoints keyPoints)
        {
            // 简化计算，实际应根据坝顶轮廓确定
            return Math.Max(2.0, CalculateBaseWidth(keyPoints) * 0.1);
        }
        
        /// <summary>
        /// 计算剖面面积（使用梯形公式）
        /// </summary>
        private double CalculateArea(List<Point2D> points)
        {
            double area = 0.0;
            int n = points.Count;
            
            for (int i = 0; i < n - 1; i++)
            {
                area += (points[i].X * points[i + 1].Y - points[i + 1].X * points[i].Y);
            }
            
            return Math.Abs(area) / 2.0;
        }
        
        /// <summary>
        /// 计算重心坐标
        /// </summary>
        private Point2D CalculateCentroid(List<Point2D> points)
        {
            double area = CalculateArea(points);
            double cx = 0.0, cy = 0.0;
            int n = points.Count;
            
            for (int i = 0; i < n - 1; i++)
            {
                double factor = (points[i].X * points[i + 1].Y - points[i + 1].X * points[i].Y);
                cx += (points[i].X + points[i + 1].X) * factor;
                cy += (points[i].Y + points[i + 1].Y) * factor;
            }
            
            return new Point2D(cx / (6.0 * area), cy / (6.0 * area));
        }
        
        /// <summary>
        /// 计算对X轴的惯性矩
        /// </summary>
        private double CalculateMomentOfInertia(List<Point2D> points)
        {
            double ixx = 0.0;
            int n = points.Count;
            
            for (int i = 0; i < n - 1; i++)
            {
                double factor = (points[i].X * points[i + 1].Y - points[i + 1].X * points[i].Y);
                ixx += (points[i].Y * points[i].Y + points[i].Y * points[i + 1].Y + 
                       points[i + 1].Y * points[i + 1].Y) * factor;
            }
            
            return ixx / 12.0;
        }
        
        /// <summary>
        /// 计算上游坡度
        /// </summary>
        private double CalculateUpstreamSlope(DamKeyPoints keyPoints)
        {
            double deltaX = keyPoints.CrestCenter.X - keyPoints.UpstreamToe.X;
            double deltaY = keyPoints.CrestCenter.Y - keyPoints.UpstreamToe.Y;
            
            return deltaX / deltaY; // 水平:垂直
        }
        
        /// <summary>
        /// 计算下游坡度
        /// </summary>
        private double CalculateDownstreamSlope(DamKeyPoints keyPoints)
        {
            double deltaX = keyPoints.DownstreamToe.X - keyPoints.CrestCenter.X;
            double deltaY = keyPoints.CrestCenter.Y - keyPoints.DownstreamToe.Y;
            
            return deltaX / deltaY; // 水平:垂直
        }
    }
}
```

### 关键数据结构

```csharp
namespace GravityDamAnalysis.Core.ValueObjects
{
    /// <summary>
    /// 坝体关键点位置
    /// </summary>
    public record DamKeyPoints
    {
        public Point2D CrestCenter { get; init; } // 坝顶中心点
        public Point2D BaseCenter { get; init; }  // 坝底中心点
        public Point2D UpstreamToe { get; init; } // 上游趾点
        public Point2D DownstreamToe { get; init; } // 下游趾点
    }
    
    /// <summary>
    /// 二维剖面几何属性
    /// </summary>
    public record Profile2DGeometryProperties
    {
        // 基本尺寸
        public double Height { get; init; }      // 坝高 (m)
        public double BaseWidth { get; init; }   // 坝底宽 (m)
        public double TopWidth { get; init; }    // 坝顶宽 (m)
        
        // 几何特性
        public double Area { get; init; }        // 剖面面积 (m²)
        public Point2D Centroid { get; init; }   // 重心坐标
        public double MomentOfInertia { get; init; } // 惯性矩 (m⁴)
        
        // 坡度信息
        public double UpstreamSlope { get; init; }   // 上游坡度（水平:垂直）
        public double DownstreamSlope { get; init; } // 下游坡度（水平:垂直）
        
        // 关键点
        public Point2D CrestCenterPoint { get; init; }
        public Point2D BaseCenterPoint { get; init; }
        public Point2D UpstreamToePoint { get; init; }
        public Point2D DownstreamToePoint { get; init; }
        
        // 计算时间
        public DateTime CalculatedAt { get; init; }
    }
}
```

## 3.3.2 荷载计算实现

### 荷载计算服务

```csharp
namespace GravityDamAnalysis.Calculation.Loads
{
    /// <summary>
    /// 荷载计算服务
    /// 计算作用在坝体上的各种荷载
    /// </summary>
    public class LoadCalculationService : ILoadCalculationService
    {
        private readonly ILogger<LoadCalculationService> _logger;
        
        public LoadCalculationService(ILogger<LoadCalculationService> logger)
        {
            _logger = logger;
        }
        
        /// <summary>
        /// 计算坝体自重
        /// W = V × γc
        /// </summary>
        public double CalculateSelfWeight(DamGeometry geometry, MaterialProperties material)
        {
            if (geometry.Volume <= 0)
                throw new ArgumentException("坝体体积必须大于0");
            
            var selfWeight = geometry.Volume * material.Density;
            
            _logger.LogDebug("坝体自重计算 - 体积: {Volume:F2}m³, 重度: {Density:F1}kN/m³, " +
                "自重: {Weight:F1}kN", geometry.Volume, material.Density, selfWeight);
            
            return selfWeight;
        }
        
        /// <summary>
        /// 计算二维自重（单位坝轴长度）
        /// W = A × γc (kN/m)
        /// </summary>
        public double CalculateSelfWeight2D(Profile2DGeometryProperties geometry, 
            MaterialProperties material)
        {
            if (geometry.Area <= 0)
                throw new ArgumentException("剖面面积必须大于0");
            
            var selfWeight2D = geometry.Area * material.Density;
            
            _logger.LogDebug("二维自重计算 - 面积: {Area:F2}m², 重度: {Density:F1}kN/m³, " +
                "单位自重: {Weight:F1}kN/m", geometry.Area, material.Density, selfWeight2D);
            
            return selfWeight2D;
        }
        
        /// <summary>
        /// 计算水平水压力
        /// P = 0.5 × γw × (H₁² - H₂²)
        /// </summary>
        public WaterPressureResult CalculateWaterPressure(AnalysisParameters parameters)
        {
            var upstreamHead = parameters.UpstreamWaterLevel;
            var downstreamHead = parameters.DownstreamWaterLevel;
            var waterDensity = parameters.WaterDensity;
            
            // 上游水压力合力 P1 = 0.5 * γw * H1² (kN/m)
            var upstreamPressure = 0.5 * waterDensity * upstreamHead * upstreamHead;
            
            // 下游水压力合力 P2 = 0.5 * γw * H2² (kN/m)
            var downstreamPressure = 0.5 * waterDensity * downstreamHead * downstreamHead;
            
            // 净水压力 (kN/m)
            var netPressure = upstreamPressure - downstreamPressure;
            
            // 作用点高度计算
            double upstreamActionHeight = upstreamHead / 3.0;
            double downstreamActionHeight = downstreamHead / 3.0;
            
            // 净水压力作用点高度（加权平均）
            double netActionHeight = 0.0;
            if (netPressure > 0)
            {
                netActionHeight = (upstreamPressure * upstreamActionHeight - 
                                  downstreamPressure * downstreamActionHeight) / netPressure;
            }
            
            var result = new WaterPressureResult
            {
                UpstreamPressure = upstreamPressure,
                DownstreamPressure = downstreamPressure,
                NetPressure = Math.Max(0, netPressure),
                UpstreamActionHeight = upstreamActionHeight,
                DownstreamActionHeight = downstreamActionHeight,
                NetActionHeight = netActionHeight
            };
            
            _logger.LogDebug("水压力计算完成 - 上游: {Upstream:F1}kN/m, 下游: {Downstream:F1}kN/m, " +
                "净压力: {Net:F1}kN/m", result.UpstreamPressure, result.DownstreamPressure, 
                result.NetPressure);
            
            return result;
        }
        
        /// <summary>
        /// 计算扬压力
        /// U = α × γw × A × H̄
        /// </summary>
        public UpliftForceResult CalculateUpliftForce(DamGeometry geometry, 
            AnalysisParameters parameters)
        {
            var upstreamLevel = parameters.UpstreamWaterLevel;
            var downstreamLevel = parameters.DownstreamWaterLevel;
            var reductionFactor = parameters.UpliftReductionFactor;
            var waterDensity = parameters.WaterDensity;
            
            // 坝底面积 (m²)
            var baseArea = geometry.BaseWidth * geometry.Length;
            
            // 平均扬压力水头（线性分布假设）
            var averageHead = (upstreamLevel + downstreamLevel) / 2.0;
            
            // 扬压力 = 折减系数 × 平均水头 × 底面积 × 水重度 (kN)
            var upliftForce = reductionFactor * averageHead * baseArea * waterDensity;
            
            var result = new UpliftForceResult
            {
                BaseArea = baseArea,
                AverageHead = averageHead,
                ReductionFactor = reductionFactor,
                UpliftForce = upliftForce,
                UpliftPressure = upliftForce / baseArea  // 平均扬压力 (kN/m²)
            };
            
            _logger.LogDebug("扬压力计算完成 - 底面积: {Area:F2}m², 平均水头: {Head:F2}m, " +
                "扬压力: {Uplift:F1}kN", result.BaseArea, result.AverageHead, result.UpliftForce);
            
            return result;
        }
        
        /// <summary>
        /// 计算二维扬压力（单位坝轴长度）
        /// U = α × γw × B × H̄ (kN/m)
        /// </summary>
        public double CalculateUpliftForce2D(Profile2DGeometryProperties geometry, 
            AnalysisParameters parameters)
        {
            var upstreamLevel = parameters.UpstreamWaterLevel;
            var downstreamLevel = parameters.DownstreamWaterLevel;
            var reductionFactor = parameters.UpliftReductionFactor;
            var waterDensity = parameters.WaterDensity;
            
            // 平均扬压力水头
            var averageHead = (upstreamLevel + downstreamLevel) / 2.0;
            
            // 扬压力 = 折减系数 × 平均水头 × 底宽 × 水重度 (kN/m)
            var upliftForce2D = reductionFactor * averageHead * geometry.BaseWidth * waterDensity;
            
            _logger.LogDebug("二维扬压力计算 - 底宽: {Width:F2}m, 平均水头: {Head:F2}m, " +
                "单位扬压力: {Uplift:F1}kN/m", geometry.BaseWidth, averageHead, upliftForce2D);
            
            return upliftForce2D;
        }
        
        /// <summary>
        /// 计算地震惯性力
        /// E = αh × W
        /// </summary>
        public SeismicForceResult CalculateSeismicForce(double selfWeight, 
            AnalysisParameters parameters)
        {
            var horizontalCoefficient = parameters.SeismicCoefficient;
            var verticalCoefficient = parameters.VerticalSeismicCoefficient;
            
            // 水平地震力 (kN)
            var horizontalForce = horizontalCoefficient * selfWeight;
            
            // 垂直地震力 (kN) - 通常较小，有时忽略
            var verticalForce = verticalCoefficient * selfWeight;
            
            var result = new SeismicForceResult
            {
                HorizontalCoefficient = horizontalCoefficient,
                VerticalCoefficient = verticalCoefficient,
                HorizontalForce = horizontalForce,
                VerticalForce = verticalForce,
                ResultantForce = Math.Sqrt(horizontalForce * horizontalForce + 
                                          verticalForce * verticalForce)
            };
            
            _logger.LogDebug("地震力计算完成 - 水平系数: {HCoeff:F3}, 水平力: {HForce:F1}kN, " +
                "垂直力: {VForce:F1}kN", result.HorizontalCoefficient, result.HorizontalForce, 
                result.VerticalForce);
            
            return result;
        }
    }
}
```

### 荷载结果数据结构

```csharp
namespace GravityDamAnalysis.Core.Models
{
    /// <summary>
    /// 水压力计算结果
    /// </summary>
    public record WaterPressureResult
    {
        public double UpstreamPressure { get; init; }     // 上游水压力 (kN/m)
        public double DownstreamPressure { get; init; }   // 下游水压力 (kN/m)
        public double NetPressure { get; init; }          // 净水压力 (kN/m)
        public double UpstreamActionHeight { get; init; } // 上游作用点高度 (m)
        public double DownstreamActionHeight { get; init; } // 下游作用点高度 (m)
        public double NetActionHeight { get; init; }      // 净压力作用点高度 (m)
    }
    
    /// <summary>
    /// 扬压力计算结果
    /// </summary>
    public record UpliftForceResult
    {
        public double BaseArea { get; init; }        // 坝底面积 (m²)
        public double AverageHead { get; init; }     // 平均扬压力水头 (m)
        public double ReductionFactor { get; init; } // 折减系数
        public double UpliftForce { get; init; }     // 扬压力 (kN)
        public double UpliftPressure { get; init; }  // 平均扬压力强度 (kN/m²)
    }
    
    /// <summary>
    /// 地震力计算结果
    /// </summary>
    public record SeismicForceResult
    {
        public double HorizontalCoefficient { get; init; } // 水平地震系数
        public double VerticalCoefficient { get; init; }   // 垂直地震系数
        public double HorizontalForce { get; init; }       // 水平地震力 (kN)
        public double VerticalForce { get; init; }         // 垂直地震力 (kN)
        public double ResultantForce { get; init; }        // 合地震力 (kN)
    }
}
```

## 3.3.3 稳定性分析算法

### 抗滑稳定性计算器

```csharp
namespace GravityDamAnalysis.Calculation.Stability
{
    /// <summary>
    /// 抗滑稳定性计算器
    /// 实现基于极限平衡法的抗滑稳定计算
    /// </summary>
    public class SlidingStabilityCalculator : ISlidingStabilityCalculator
    {
        private readonly ILoadCalculationService _loadService;
        private readonly ILogger<SlidingStabilityCalculator> _logger;
        
        public SlidingStabilityCalculator(
            ILoadCalculationService loadService,
            ILogger<SlidingStabilityCalculator> logger)
        {
            _loadService = loadService;
            _logger = logger;
        }
        
        /// <summary>
        /// 计算抗滑稳定安全系数
        /// Ks = ΣR / ΣS = f(W - U) / (P + E)
        /// </summary>
        public async Task<SlidingStabilityResult> CalculateAsync(
            DamEntity damEntity, 
            AnalysisParameters parameters)
        {
            _logger.LogInformation("开始抗滑稳定计算 - 坝体: {DamName}", damEntity.Name);
            
            var result = new SlidingStabilityResult
            {
                CalculationMethod = "极限平衡法",
                Parameters = parameters,
                CalculatedAt = DateTime.UtcNow
            };
            
            try
            {
                // 1. 计算坝体自重 (kN)
                var selfWeight = _loadService.CalculateSelfWeight(
                    damEntity.Geometry, damEntity.MaterialProperties);
                result.SelfWeight = selfWeight;
                
                // 2. 计算水平水压力 (kN)
                var waterPressure = _loadService.CalculateWaterPressure(parameters);
                result.WaterPressure = waterPressure.NetPressure * damEntity.Geometry.Length;
                
                // 3. 计算扬压力 (kN)
                var upliftForce = _loadService.CalculateUpliftForce(
                    damEntity.Geometry, parameters);
                result.UpliftForce = upliftForce.UpliftForce;
                
                // 4. 计算地震惯性力 (kN)
                var seismicForce = _loadService.CalculateSeismicForce(selfWeight, parameters);
                result.SeismicForce = seismicForce.HorizontalForce;
                
                // 5. 计算有效法向力 (kN)
                result.EffectiveNormalForce = selfWeight - upliftForce.UpliftForce;
                
                // 验证有效法向力
                if (result.EffectiveNormalForce <= 0)
                {
                    _logger.LogWarning("有效法向力为负值，扬压力过大，设计可能不合理");
                    result.IsValid = false;
                    result.WarningMessage = "扬压力过大，建议设置排水措施";
                }
                
                // 6. 计算抗滑力 (kN)
                var frictionCoeff = damEntity.MaterialProperties.FrictionCoefficient;
                var cohesion = damEntity.MaterialProperties.CohesionStrength;
                var baseArea = damEntity.Geometry.BaseWidth * damEntity.Geometry.Length;
                
                // 抗滑力 = 摩擦力 + 粘聚力（如果考虑）
                result.ResistingForce = frictionCoeff * Math.Max(0, result.EffectiveNormalForce);
                if (parameters.ConsiderCohesion && cohesion > 0)
                {
                    result.ResistingForce += cohesion * baseArea;
                }
                
                // 7. 计算滑动力 (kN)
                result.SlidingForce = result.WaterPressure + result.SeismicForce;
                
                // 8. 计算安全系数
                if (result.SlidingForce > 0)
                {
                    result.SafetyFactor = result.ResistingForce / result.SlidingForce;
                }
                else
                {
                    result.SafetyFactor = double.MaxValue;
                    _logger.LogWarning("滑动力为零或负值，计算结果可能异常");
                }
                
                // 9. 评估稳定性状态
                result.StabilityStatus = EvaluateStabilityStatus(
                    result.SafetyFactor, parameters);
                
                result.IsValid = true;
                
                _logger.LogInformation("抗滑稳定计算完成 - 安全系数: {SF:F3}, 状态: {Status}",
                    result.SafetyFactor, result.StabilityStatus);
                
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "抗滑稳定计算失败");
                result.IsValid = false;
                result.ErrorMessage = ex.Message;
                return result;
            }
        }
        
        /// <summary>
        /// 评估稳定性状态
        /// </summary>
        private StabilityStatus EvaluateStabilityStatus(double safetyFactor, 
            AnalysisParameters parameters)
        {
            var requiredSF = parameters.RequiredSlidingSafetyFactor;
            
            if (safetyFactor >= requiredSF * 1.2)
                return StabilityStatus.Safe;
            else if (safetyFactor >= requiredSF)
                return StabilityStatus.Acceptable;
            else if (safetyFactor >= requiredSF * 0.9)
                return StabilityStatus.Marginal;
            else
                return StabilityStatus.Unsafe;
        }
    }
}
```

### 抗倾覆稳定性计算器

```csharp
namespace GravityDamAnalysis.Calculation.Stability
{
    /// <summary>
    /// 抗倾覆稳定性计算器
    /// 基于力矩平衡原理
    /// </summary>
    public class OverturnStabilityCalculator : IOverturnStabilityCalculator
    {
        private readonly ILoadCalculationService _loadService;
        private readonly ILogger<OverturnStabilityCalculator> _logger;
        
        public async Task<OverturnStabilityResult> CalculateAsync(
            DamEntity damEntity, 
            AnalysisParameters parameters)
        {
            _logger.LogInformation("开始抗倾覆稳定计算 - 坝体: {DamName}", damEntity.Name);
            
            var result = new OverturnStabilityResult
            {
                CalculationMethod = "力矩平衡法",
                Parameters = parameters,
                CalculatedAt = DateTime.UtcNow
            };
            
            try
            {
                // 1. 计算坝体自重和重心位置
                var selfWeight = _loadService.CalculateSelfWeight(
                    damEntity.Geometry, damEntity.MaterialProperties);
                var centroidX = damEntity.Geometry.Centroid.X; // 重心X坐标
                var centroidY = damEntity.Geometry.Centroid.Y; // 重心Y坐标
                
                // 2. 计算抗倾覆力矩（以坝趾为转动中心）
                // 假设坝趾位于坐标原点
                result.SelfWeightMoment = selfWeight * centroidX;
                result.ResistingMoment = result.SelfWeightMoment;
                
                // 3. 计算水压力及其倾覆力矩
                var waterPressure = _loadService.CalculateWaterPressure(parameters);
                var totalWaterForce = waterPressure.NetPressure * damEntity.Geometry.Length;
                var waterActionHeight = waterPressure.NetActionHeight;
                result.WaterPressureMoment = totalWaterForce * waterActionHeight;
                
                // 4. 计算地震力及其倾覆力矩
                var seismicForce = _loadService.CalculateSeismicForce(selfWeight, parameters);
                result.SeismicForceMoment = seismicForce.HorizontalForce * centroidY;
                
                // 5. 计算总倾覆力矩
                result.OverturnMoment = result.WaterPressureMoment + result.SeismicForceMoment;
                
                // 6. 计算安全系数
                if (result.OverturnMoment > 0)
                {
                    result.SafetyFactor = result.ResistingMoment / result.OverturnMoment;
                }
                else
                {
                    result.SafetyFactor = double.MaxValue;
                }
                
                // 7. 计算合力偏心距
                var totalVerticalForce = selfWeight;
                var totalHorizontalForce = totalWaterForce + seismicForce.HorizontalForce;
                var netMoment = result.ResistingMoment - result.OverturnMoment;
                
                result.Eccentricity = Math.Abs(netMoment / totalVerticalForce);
                result.BaseWidth = damEntity.Geometry.BaseWidth;
                result.MiddleThird = result.BaseWidth / 6.0; // 中核范围
                
                // 8. 评估稳定性状态
                result.StabilityStatus = EvaluateOverturnStability(
                    result.SafetyFactor, result.Eccentricity, 
                    result.MiddleThird, parameters);
                
                result.IsValid = true;
                
                _logger.LogInformation("抗倾覆稳定计算完成 - 安全系数: {SF:F3}, " +
                    "偏心距: {Ecc:F3}m, 状态: {Status}",
                    result.SafetyFactor, result.Eccentricity, result.StabilityStatus);
                
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "抗倾覆稳定计算失败");
                result.IsValid = false;
                result.ErrorMessage = ex.Message;
                return result;
            }
        }
        
        /// <summary>
        /// 评估抗倾覆稳定性状态
        /// </summary>
        private StabilityStatus EvaluateOverturnStability(double safetyFactor, 
            double eccentricity, double middleThird, AnalysisParameters parameters)
        {
            var requiredSF = parameters.RequiredOverturnSafetyFactor;
            
            // 首先检查偏心距
            if (eccentricity > middleThird)
            {
                _logger.LogWarning("合力偏心距超出中核范围，可能出现拉应力");
                return StabilityStatus.Marginal; // 至少是边缘状态
            }
            
            // 然后检查安全系数
            if (safetyFactor >= requiredSF * 1.2)
                return StabilityStatus.Safe;
            else if (safetyFactor >= requiredSF)
                return StabilityStatus.Acceptable;
            else if (safetyFactor >= requiredSF * 0.9)
                return StabilityStatus.Marginal;
            else
                return StabilityStatus.Unsafe;
        }
    }
}
```

### 稳定性结果数据结构

```csharp
namespace GravityDamAnalysis.Core.Models
{
    /// <summary>
    /// 抗滑稳定计算结果
    /// </summary>
    public class SlidingStabilityResult
    {
        public string CalculationMethod { get; set; }
        public AnalysisParameters Parameters { get; set; }
        public DateTime CalculatedAt { get; set; }
        
        // 荷载项
        public double SelfWeight { get; set; }           // 自重 (kN)
        public double WaterPressure { get; set; }        // 水压力 (kN)
        public double UpliftForce { get; set; }          // 扬压力 (kN)
        public double SeismicForce { get; set; }         // 地震力 (kN)
        public double EffectiveNormalForce { get; set; } // 有效法向力 (kN)
        
        // 计算结果
        public double ResistingForce { get; set; }       // 抗滑力 (kN)
        public double SlidingForce { get; set; }         // 滑动力 (kN)
        public double SafetyFactor { get; set; }         // 安全系数
        
        // 状态评估
        public StabilityStatus StabilityStatus { get; set; }
        public bool IsValid { get; set; }
        public string WarningMessage { get; set; }
        public string ErrorMessage { get; set; }
    }
    
    /// <summary>
    /// 抗倾覆稳定计算结果
    /// </summary>
    public class OverturnStabilityResult
    {
        public string CalculationMethod { get; set; }
        public AnalysisParameters Parameters { get; set; }
        public DateTime CalculatedAt { get; set; }
        
        // 力矩项
        public double SelfWeightMoment { get; set; }     // 自重力矩 (kN·m)
        public double ResistingMoment { get; set; }      // 抗倾覆力矩 (kN·m)
        public double WaterPressureMoment { get; set; }  // 水压力矩 (kN·m)
        public double SeismicForceMoment { get; set; }   // 地震力矩 (kN·m)
        public double OverturnMoment { get; set; }       // 总倾覆力矩 (kN·m)
        
        // 计算结果
        public double SafetyFactor { get; set; }         // 安全系数
        public double Eccentricity { get; set; }         // 偏心距 (m)
        public double BaseWidth { get; set; }            // 坝底宽 (m)
        public double MiddleThird { get; set; }          // 中核范围 (m)
        
        // 状态评估
        public StabilityStatus StabilityStatus { get; set; }
        public bool IsValid { get; set; }
        public string WarningMessage { get; set; }
        public string ErrorMessage { get; set; }
    }
    
    /// <summary>
    /// 稳定性状态枚举
    /// </summary>
    public enum StabilityStatus
    {
        Safe,        // 安全
        Acceptable,  // 可接受
        Marginal,    // 边缘
        Unsafe       // 不安全
    }
}
```

---

## 本节小结

本节详细介绍了重力坝稳定计算插件的核心算法实现，主要内容包括：

1. **几何参数提取**：从二维剖面轮廓计算几何特性的完整算法
2. **荷载计算**：自重、水压力、扬压力、地震力的精确计算方法
3. **稳定性分析**：抗滑和抗倾覆稳定性的详细计算实现

### 算法特点

- **精确性**：采用工程实际使用的计算公式
- **鲁棒性**：包含完整的异常处理和边界条件检查
- **可扩展性**：模块化设计便于功能扩展
- **可观测性**：详细的日志记录便于调试和监控

### 关键技术点

1. **几何分析**：使用梯形公式计算面积和重心
2. **荷载建模**：考虑了各种工程实际情况
3. **稳定性判断**：基于规范要求的分级评估体系
4. **异步设计**：支持异步计算提高响应性能

下一节将介绍这些算法如何与Revit API集成。
