# 4.3 应力计算求解器实现

## 4.3.1 有限元求解器架构

### 求解器核心架构

有限元应力计算求解器是整个系统的核心计算引擎，需要处理大规模稀疏矩阵运算：

```csharp
namespace GravityDamAnalysis.StressAnalysis.Solver
{
    /// <summary>
    /// 有限元应力分析求解器
    /// </summary>
    public class FiniteElementSolver
    {
        private readonly ILogger<FiniteElementSolver> _logger;
        private readonly IMatrixSolver _matrixSolver;
        private readonly IElementProcessor _elementProcessor;
        private readonly ILoadProcessor _loadProcessor;
        
        public FiniteElementSolver(
            ILogger<FiniteElementSolver> logger,
            IMatrixSolver matrixSolver,
            IElementProcessor elementProcessor,
            ILoadProcessor loadProcessor)
        {
            _logger = logger;
            _matrixSolver = matrixSolver;
            _elementProcessor = elementProcessor;
            _loadProcessor = loadProcessor;
        }
        
        /// <summary>
        /// 执行有限元应力分析
        /// </summary>
        /// <param name="analysisMesh">分析网格</param>
        /// <param name="analysisParameters">分析参数</param>
        /// <returns>应力分析结果</returns>
        public async Task<StressAnalysisResult> SolveStressAnalysisAsync(
            AnalysisMesh analysisMesh,
            StressAnalysisParameters analysisParameters)
        {
            _logger.LogInformation("开始有限元应力分析求解");
            
            var stopwatch = Stopwatch.StartNew();
            
            try
            {
                // 1. 初始化求解器
                InitializeSolver(analysisMesh, analysisParameters);
                
                // 2. 组装整体刚度矩阵
                var globalStiffnessMatrix = await AssembleGlobalStiffnessMatrixAsync(analysisMesh);
                _logger.LogDebug("整体刚度矩阵组装完成，维数: {Size}x{Size}", 
                    globalStiffnessMatrix.RowCount, globalStiffnessMatrix.ColumnCount);
                
                // 3. 组装载荷向量
                var loadVector = await AssembleLoadVectorAsync(analysisMesh, analysisParameters);
                _logger.LogDebug("载荷向量组装完成，长度: {Length}", loadVector.Count);
                
                // 4. 应用边界条件
                ApplyBoundaryConditions(globalStiffnessMatrix, loadVector, analysisMesh);
                _logger.LogDebug("边界条件应用完成");
                
                // 5. 求解线性方程组
                var displacementVector = await _matrixSolver.SolveAsync(globalStiffnessMatrix, loadVector);
                _logger.LogDebug("位移求解完成");
                
                // 6. 计算应力和应变
                var stressResults = await CalculateStressAndStrainAsync(
                    analysisMesh, displacementVector, analysisParameters);
                _logger.LogDebug("应力应变计算完成");
                
                // 7. 后处理和结果验证
                var analysisResult = await PostProcessResultsAsync(
                    analysisMesh, displacementVector, stressResults, analysisParameters);
                
                stopwatch.Stop();
                _logger.LogInformation("有限元求解完成，耗时: {Elapsed:F2}秒", stopwatch.Elapsed.TotalSeconds);
                
                return analysisResult;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "有限元求解过程中发生错误");
                throw;
            }
        }
        
        /// <summary>
        /// 初始化求解器
        /// </summary>
        private void InitializeSolver(AnalysisMesh analysisMesh, StressAnalysisParameters parameters)
        {
            _logger.LogDebug("初始化求解器");
            
            // 验证输入数据
            ValidateInput(analysisMesh, parameters);
            
            // 配置求解器参数
            ConfigureSolverParameters(parameters);
            
            // 预分配内存
            PreallocateMemory(analysisMesh);
        }
        
        /// <summary>
        /// 组装整体刚度矩阵
        /// </summary>
        private async Task<Matrix<double>> AssembleGlobalStiffnessMatrixAsync(AnalysisMesh analysisMesh)
        {
            var mesh = analysisMesh.Mesh;
            var totalDOF = mesh.Nodes.Count * 2; // 每个节点2个自由度（平面问题）
            
            // 使用稀疏矩阵存储
            var globalMatrix = Matrix<double>.Build.Sparse(totalDOF, totalDOF);
            
            _logger.LogDebug("开始组装整体刚度矩阵，总自由度: {DOF}", totalDOF);
            
            // 并行处理单元刚度矩阵
            var elementMatrices = await Task.Run(() =>
                mesh.Elements.AsParallel().Select(element =>
                {
                    var elementMatrix = _elementProcessor.CalculateElementStiffnessMatrix(element, mesh.Nodes);
                    return new { Element = element, Matrix = elementMatrix };
                }).ToList());
            
            // 组装到整体矩阵
            foreach (var item in elementMatrices)
            {
                AssembleElementMatrix(globalMatrix, item.Element, item.Matrix);
            }
            
            _logger.LogDebug("整体刚度矩阵组装完成");
            return globalMatrix;
        }
        
        /// <summary>
        /// 组装单元矩阵到整体矩阵
        /// </summary>
        private void AssembleElementMatrix(
            Matrix<double> globalMatrix,
            TriangleElement element,
            Matrix<double> elementMatrix)
        {
            var dofs = GetElementDOFs(element);
            
            for (int i = 0; i < dofs.Length; i++)
            {
                for (int j = 0; j < dofs.Length; j++)
                {
                    var globalI = dofs[i];
                    var globalJ = dofs[j];
                    
                    globalMatrix[globalI, globalJ] += elementMatrix[i, j];
                }
            }
        }
        
        /// <summary>
        /// 获取单元自由度编号
        /// </summary>
        private int[] GetElementDOFs(TriangleElement element)
        {
            var dofs = new int[6]; // 3节点 × 2自由度
            
            for (int i = 0; i < 3; i++)
            {
                var nodeId = element.NodeIds[i];
                dofs[2 * i] = 2 * nodeId;     // X方向自由度
                dofs[2 * i + 1] = 2 * nodeId + 1; // Y方向自由度
            }
            
            return dofs;
        }
        
        /// <summary>
        /// 组装载荷向量
        /// </summary>
        private async Task<Vector<double>> AssembleLoadVectorAsync(
            AnalysisMesh analysisMesh,
            StressAnalysisParameters parameters)
        {
            var mesh = analysisMesh.Mesh;
            var totalDOF = mesh.Nodes.Count * 2;
            var loadVector = Vector<double>.Build.Dense(totalDOF);
            
            _logger.LogDebug("开始组装载荷向量");
            
            // 1. 体积力（重力）
            await AddBodyForcesAsync(loadVector, mesh, parameters);
            
            // 2. 表面力（水压力）
            await AddSurfaceForcesAsync(loadVector, mesh, parameters);
            
            // 3. 集中力
            await AddConcentratedForcesAsync(loadVector, mesh, parameters);
            
            _logger.LogDebug("载荷向量组装完成");
            return loadVector;
        }
        
        /// <summary>
        /// 添加体积力
        /// </summary>
        private async Task AddBodyForcesAsync(
            Vector<double> loadVector,
            TriangularMesh mesh,
            StressAnalysisParameters parameters)
        {
            await Task.Run(() =>
            {
                foreach (var element in mesh.Elements)
                {
                    var bodyForceVector = _loadProcessor.CalculateElementBodyForce(element, mesh.Nodes, parameters);
                    var dofs = GetElementDOFs(element);
                    
                    for (int i = 0; i < dofs.Length; i++)
                    {
                        loadVector[dofs[i]] += bodyForceVector[i];
                    }
                }
            });
        }
        
        /// <summary>
        /// 添加表面力
        /// </summary>
        private async Task AddSurfaceForcesAsync(
            Vector<double> loadVector,
            TriangularMesh mesh,
            StressAnalysisParameters parameters)
        {
            await Task.Run(() =>
            {
                foreach (var boundaryEdge in mesh.BoundaryEdges.Where(be => be.Type == BoundaryType.Pressure))
                {
                    var surfaceForceVector = _loadProcessor.CalculateSurfaceForce(boundaryEdge, mesh.Nodes, parameters);
                    
                    // 将边界力分配到相关节点
                    var startDOF_X = 2 * boundaryEdge.StartNodeId;
                    var startDOF_Y = 2 * boundaryEdge.StartNodeId + 1;
                    var endDOF_X = 2 * boundaryEdge.EndNodeId;
                    var endDOF_Y = 2 * boundaryEdge.EndNodeId + 1;
                    
                    loadVector[startDOF_X] += surfaceForceVector[0];
                    loadVector[startDOF_Y] += surfaceForceVector[1];
                    loadVector[endDOF_X] += surfaceForceVector[2];
                    loadVector[endDOF_Y] += surfaceForceVector[3];
                }
            });
        }
        
        /// <summary>
        /// 应用边界条件
        /// </summary>
        private void ApplyBoundaryConditions(
            Matrix<double> globalMatrix,
            Vector<double> loadVector,
            AnalysisMesh analysisMesh)
        {
            _logger.LogDebug("应用边界条件");
            
            var fixedDOFs = new List<int>();
            
            // 收集固定自由度
            foreach (var node in analysisMesh.Mesh.Nodes.Where(n => n.IsFixed))
            {
                fixedDOFs.Add(2 * node.Id);     // X方向固定
                fixedDOFs.Add(2 * node.Id + 1); // Y方向固定
            }
            
            // 应用位移边界条件（处罚法）
            const double penaltyFactor = 1e12;
            
            foreach (var dof in fixedDOFs)
            {
                globalMatrix[dof, dof] += penaltyFactor;
                loadVector[dof] = 0.0; // 零位移
            }
            
            _logger.LogDebug("边界条件应用完成，固定自由度数: {Count}", fixedDOFs.Count);
        }
    }
}
```

### 单元处理器

```csharp
/// <summary>
/// 单元处理器 - 计算单元刚度矩阵和载荷向量
/// </summary>
public class ElementProcessor : IElementProcessor
{
    private readonly ILogger<ElementProcessor> _logger;
    
    public ElementProcessor(ILogger<ElementProcessor> logger)
    {
        _logger = logger;
    }
    
    /// <summary>
    /// 计算三角形单元刚度矩阵
    /// </summary>
    public Matrix<double> CalculateElementStiffnessMatrix(
        TriangleElement element,
        List<Node2D> nodes)
    {
        // 获取单元节点坐标
        var elementNodes = element.NodeIds.Select(id => nodes.First(n => n.Id == id)).ToArray();
        
        // 计算单元几何参数
        var area = element.CalculateArea(nodes);
        if (area <= 0)
        {
            throw new InvalidOperationException($"单元 {element.Id} 面积无效: {area}");
        }
        
        // 计算B矩阵（应变-位移矩阵）
        var bMatrix = CalculateBMatrix(elementNodes, area);
        
        // 获取材料弹性矩阵
        var dMatrix = GetMaterialMatrix(element.MaterialId);
        
        // 计算单元刚度矩阵: K = ∫ B^T D B dV = t × A × B^T D B
        var thickness = element.Thickness;
        var stiffnessMatrix = thickness * area * bMatrix.Transpose() * dMatrix * bMatrix;
        
        return stiffnessMatrix;
    }
    
    /// <summary>
    /// 计算应变-位移矩阵（B矩阵）
    /// </summary>
    private Matrix<double> CalculateBMatrix(Node2D[] nodes, double area)
    {
        // 对于常应变三角形单元，B矩阵为常数矩阵
        var x1 = nodes[0].X; var y1 = nodes[0].Y;
        var x2 = nodes[1].X; var y2 = nodes[1].Y;
        var x3 = nodes[2].X; var y3 = nodes[2].Y;
        
        // 计算形函数偏导数
        var b1 = (y2 - y3) / (2 * area);
        var b2 = (y3 - y1) / (2 * area);
        var b3 = (y1 - y2) / (2 * area);
        
        var c1 = (x3 - x2) / (2 * area);
        var c2 = (x1 - x3) / (2 * area);
        var c3 = (x2 - x1) / (2 * area);
        
        // 构建B矩阵 (3×6)
        var B = Matrix<double>.Build.Dense(3, 6);
        
        // εx = ∂u/∂x
        B[0, 0] = b1; B[0, 2] = b2; B[0, 4] = b3;
        
        // εy = ∂v/∂y
        B[1, 1] = c1; B[1, 3] = c2; B[1, 5] = c3;
        
        // γxy = ∂u/∂y + ∂v/∂x
        B[2, 0] = c1; B[2, 1] = b1;
        B[2, 2] = c2; B[2, 3] = b2;
        B[2, 4] = c3; B[2, 5] = b3;
        
        return B;
    }
    
    /// <summary>
    /// 获取材料弹性矩阵
    /// </summary>
    private Matrix<double> GetMaterialMatrix(int materialId)
    {
        // 从材料库获取材料属性
        // 这里使用混凝土的典型参数
        var E = 30000e6; // 弹性模量 30GPa
        var nu = 0.2;    // 泊松比 0.2
        
        // 平面应变弹性矩阵
        var factor = E / ((1 + nu) * (1 - 2 * nu));
        var D = Matrix<double>.Build.Dense(3, 3);
        
        D[0, 0] = factor * (1 - nu);
        D[0, 1] = factor * nu;
        D[1, 0] = factor * nu;
        D[1, 1] = factor * (1 - nu);
        D[2, 2] = factor * (1 - 2 * nu) / 2;
        
        return D;
    }
    
    /// <summary>
    /// 计算单元应力
    /// </summary>
    public StressTensor CalculateElementStress(
        TriangleElement element,
        List<Node2D> nodes,
        Vector<double> globalDisplacement)
    {
        // 提取单元位移
        var elementDisplacement = ExtractElementDisplacement(element, globalDisplacement);
        
        // 计算B矩阵
        var area = element.CalculateArea(nodes);
        var elementNodes = element.NodeIds.Select(id => nodes.First(n => n.Id == id)).ToArray();
        var bMatrix = CalculateBMatrix(elementNodes, area);
        
        // 计算应变: ε = B × u
        var strain = bMatrix * elementDisplacement;
        
        // 计算应力: σ = D × ε
        var dMatrix = GetMaterialMatrix(element.MaterialId);
        var stress = dMatrix * strain;
        
        return new StressTensor
        {
            XX = stress[0],
            YY = stress[1],
            XY = stress[2],
            ZZ = 0.0 // 平面应变，σz = ν(σx + σy)
        };
    }
    
    /// <summary>
    /// 提取单元位移向量
    /// </summary>
    private Vector<double> ExtractElementDisplacement(
        TriangleElement element,
        Vector<double> globalDisplacement)
    {
        var elementDisplacement = Vector<double>.Build.Dense(6);
        
        for (int i = 0; i < 3; i++)
        {
            var nodeId = element.NodeIds[i];
            elementDisplacement[2 * i] = globalDisplacement[2 * nodeId];         // u
            elementDisplacement[2 * i + 1] = globalDisplacement[2 * nodeId + 1]; // v
        }
        
        return elementDisplacement;
    }
}
```

### 载荷处理器

```csharp
/// <summary>
/// 载荷处理器 - 计算各种载荷的等效节点力
/// </summary>
public class LoadProcessor : ILoadProcessor
{
    private readonly ILogger<LoadProcessor> _logger;
    
    public LoadProcessor(ILogger<LoadProcessor> logger)
    {
        _logger = logger;
    }
    
    /// <summary>
    /// 计算单元体积力（重力）等效节点力
    /// </summary>
    public Vector<double> CalculateElementBodyForce(
        TriangleElement element,
        List<Node2D> nodes,
        StressAnalysisParameters parameters)
    {
        var area = element.CalculateArea(nodes);
        var thickness = element.Thickness;
        var density = GetMaterialDensity(element.MaterialId);
        var gravity = 9.8; // m/s²
        
        // 体积力强度
        var bodyForceY = -density * gravity; // 重力向下
        
        // 等效节点力（每个节点分担1/3）
        var nodeForce = area * thickness * bodyForceY / 3.0;
        
        var elementForce = Vector<double>.Build.Dense(6);
        // 只有Y方向有重力
        elementForce[1] = nodeForce; // 节点1 Y方向
        elementForce[3] = nodeForce; // 节点2 Y方向
        elementForce[5] = nodeForce; // 节点3 Y方向
        
        return elementForce;
    }
    
    /// <summary>
    /// 计算表面力（水压力）等效节点力
    /// </summary>
    public Vector<double> CalculateSurfaceForce(
        BoundaryEdge boundaryEdge,
        List<Node2D> nodes,
        StressAnalysisParameters parameters)
    {
        var startNode = nodes.First(n => n.Id == boundaryEdge.StartNodeId);
        var endNode = nodes.First(n => n.Id == boundaryEdge.EndNodeId);
        
        // 计算边长
        var edgeLength = Math.Sqrt(
            Math.Pow(endNode.X - startNode.X, 2) + 
            Math.Pow(endNode.Y - startNode.Y, 2));
        
        // 计算边的方向向量和法向量
        var edgeVector = new Vector2D(endNode.X - startNode.X, endNode.Y - startNode.Y);
        edgeVector = edgeVector.Normalize();
        var normalVector = new Vector2D(-edgeVector.Y, edgeVector.X); // 向外法向量
        
        // 计算水压力
        var waterPressureStart = CalculateWaterPressure(startNode, parameters);
        var waterPressureEnd = CalculateWaterPressure(endNode, parameters);
        
        // 线性分布载荷的等效节点力
        var totalForceStart = waterPressureStart * edgeLength / 3.0; // 1/3 分配给起点
        var totalForceEnd = waterPressureEnd * edgeLength / 3.0;     // 1/3 分配给终点
        var totalForceMiddle = (waterPressureStart + waterPressureEnd) * edgeLength / 6.0; // 各1/6
        
        var surfaceForce = Vector<double>.Build.Dense(4);
        
        // 起点节点力
        surfaceForce[0] = (totalForceStart + totalForceMiddle) * normalVector.X;
        surfaceForce[1] = (totalForceStart + totalForceMiddle) * normalVector.Y;
        
        // 终点节点力
        surfaceForce[2] = (totalForceEnd + totalForceMiddle) * normalVector.X;
        surfaceForce[3] = (totalForceEnd + totalForceMiddle) * normalVector.Y;
        
        return surfaceForce;
    }
    
    /// <summary>
    /// 计算节点处的水压力
    /// </summary>
    private double CalculateWaterPressure(Node2D node, StressAnalysisParameters parameters)
    {
        // 判断是上游面还是下游面
        bool isUpstream = DetermineUpstreamSide(node, parameters);
        
        double waterLevel = isUpstream ? parameters.UpstreamWaterLevel : parameters.DownstreamWaterLevel;
        double waterDepth = Math.Max(0, waterLevel - node.Y);
        
        return waterDepth * 9800; // γw = 9800 N/m³
    }
    
    /// <summary>
    /// 判断节点是否在上游面
    /// </summary>
    private bool DetermineUpstreamSide(Node2D node, StressAnalysisParameters parameters)
    {
        // 简化判断：X坐标小于某个阈值为上游面
        // 实际应用中需要根据具体的坝体几何形状判断
        return node.X < parameters.DamCenterX;
    }
    
    /// <summary>
    /// 获取材料密度
    /// </summary>
    private double GetMaterialDensity(int materialId)
    {
        // 从材料库获取密度
        // 混凝土典型密度
        return 2400; // kg/m³
    }
}
```

## 4.3.2 矩阵求解器

### 稀疏矩阵求解器

大规模有限元问题需要高效的稀疏矩阵求解器：

```csharp
/// <summary>
/// 稀疏矩阵求解器
/// </summary>
public class SparseMatrixSolver : IMatrixSolver
{
    private readonly ILogger<SparseMatrixSolver> _logger;
    
    public SparseMatrixSolver(ILogger<SparseMatrixSolver> logger)
    {
        _logger = logger;
    }
    
    /// <summary>
    /// 求解稀疏线性方程组 Ax = b
    /// </summary>
    public async Task<Vector<double>> SolveAsync(Matrix<double> A, Vector<double> b)
    {
        _logger.LogInformation("开始求解稀疏线性方程组，维数: {Size}", A.RowCount);
        
        var stopwatch = Stopwatch.StartNew();
        
        try
        {
            // 选择求解方法
            var solverMethod = SelectSolverMethod(A);
            
            Vector<double> solution;
            
            switch (solverMethod)
            {
                case SolverMethod.DirectLU:
                    solution = await SolveDirectLUAsync(A, b);
                    break;
                
                case SolverMethod.DirectCholesky:
                    solution = await SolveDirectCholeskyAsync(A, b);
                    break;
                
                case SolverMethod.IterativeCG:
                    solution = await SolveIterativeCGAsync(A, b);
                    break;
                
                case SolverMethod.IterativeGMRES:
                    solution = await SolveIterativeGMRESAsync(A, b);
                    break;
                
                default:
                    throw new NotSupportedException($"不支持的求解方法: {solverMethod}");
            }
            
            stopwatch.Stop();
            _logger.LogInformation("线性方程组求解完成，耗时: {Elapsed:F2}秒，方法: {Method}", 
                stopwatch.Elapsed.TotalSeconds, solverMethod);
            
            // 验证解的精度
            await ValidateSolutionAsync(A, b, solution);
            
            return solution;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "线性方程组求解失败");
            throw;
        }
    }
    
    /// <summary>
    /// 选择求解方法
    /// </summary>
    private SolverMethod SelectSolverMethod(Matrix<double> A)
    {
        var size = A.RowCount;
        var sparsity = CalculateSparsity(A);
        var isSymmetric = IsSymmetric(A);
        var isPositiveDefinite = IsPositiveDefinite(A);
        
        _logger.LogDebug("矩阵特性 - 维数: {Size}, 稀疏度: {Sparsity:P2}, 对称: {Symmetric}, 正定: {PositiveDefinite}",
            size, sparsity, isSymmetric, isPositiveDefinite);
        
        // 根据矩阵特性选择最优求解方法
        if (size < 5000)
        {
            // 小规模问题使用直接法
            return isSymmetric && isPositiveDefinite ? SolverMethod.DirectCholesky : SolverMethod.DirectLU;
        }
        else
        {
            // 大规模问题使用迭代法
            return isSymmetric && isPositiveDefinite ? SolverMethod.IterativeCG : SolverMethod.IterativeGMRES;
        }
    }
    
    /// <summary>
    /// LU分解直接求解
    /// </summary>
    private async Task<Vector<double>> SolveDirectLUAsync(Matrix<double> A, Vector<double> b)
    {
        return await Task.Run(() =>
        {
            _logger.LogDebug("使用LU分解求解");
            
            // 执行LU分解
            var lu = A.LU();
            
            // 求解
            var solution = lu.Solve(b);
            
            return solution;
        });
    }
    
    /// <summary>
    /// Cholesky分解直接求解（适用于对称正定矩阵）
    /// </summary>
    private async Task<Vector<double>> SolveDirectCholeskyAsync(Matrix<double> A, Vector<double> b)
    {
        return await Task.Run(() =>
        {
            _logger.LogDebug("使用Cholesky分解求解");
            
            // 执行Cholesky分解
            var cholesky = A.Cholesky();
            
            // 求解
            var solution = cholesky.Solve(b);
            
            return solution;
        });
    }
    
    /// <summary>
    /// 共轭梯度法迭代求解
    /// </summary>
    private async Task<Vector<double>> SolveIterativeCGAsync(Matrix<double> A, Vector<double> b)
    {
        return await Task.Run(() =>
        {
            _logger.LogDebug("使用共轭梯度法求解");
            
            var size = A.RowCount;
            var x = Vector<double>.Build.Dense(size, 0.0); // 初始解
            var r = b - A * x; // 初始残差
            var p = r.Clone(); // 初始搜索方向
            var rsold = r.DotProduct(r);
            
            const double tolerance = 1e-8;
            const int maxIterations = Math.Min(size, 10000);
            
            for (int iteration = 0; iteration < maxIterations; iteration++)
            {
                var Ap = A * p;
                var alpha = rsold / p.DotProduct(Ap);
                
                x = x + alpha * p;
                r = r - alpha * Ap;
                
                var rsnew = r.DotProduct(r);
                var residualNorm = Math.Sqrt(rsnew);
                
                if (iteration % 100 == 0)
                {
                    _logger.LogDebug("CG迭代 {Iteration}: 残差 = {Residual:E3}", iteration, residualNorm);
                }
                
                if (residualNorm < tolerance)
                {
                    _logger.LogDebug("CG收敛，迭代次数: {Iterations}, 最终残差: {Residual:E3}", 
                        iteration + 1, residualNorm);
                    break;
                }
                
                var beta = rsnew / rsold;
                p = r + beta * p;
                rsold = rsnew;
            }
            
            return x;
        });
    }
    
    /// <summary>
    /// GMRES方法求解
    /// </summary>
    private async Task<Vector<double>> SolveIterativeGMRESAsync(Matrix<double> A, Vector<double> b)
    {
        return await Task.Run(() =>
        {
            _logger.LogDebug("使用GMRES方法求解");
            
            // 使用Math.NET Numerics的内置GMRES求解器
            var iterativeSolver = new MathNet.Numerics.LinearAlgebra.Double.Solvers.GpBiCg();
            
            var solution = Vector<double>.Build.Dense(A.RowCount);
            var iterator = new Iterator<double>
            {
                MaximumIterations = Math.Min(A.RowCount, 10000),
                DivergenceThreshold = double.PositiveInfinity,
                Tolerance = 1e-8
            };
            
            iterativeSolver.Solve(A, b, solution, iterator, null);
            
            _logger.LogDebug("GMRES收敛，迭代次数: {Iterations}, 最终残差: {Residual:E3}",
                iterator.IterationCountAtEnd, iterator.ResidualNormAtEnd);
            
            return solution;
        });
    }
    
    /// <summary>
    /// 计算矩阵稀疏度
    /// </summary>
    private double CalculateSparsity(Matrix<double> A)
    {
        var totalElements = A.RowCount * A.ColumnCount;
        var nonZeroElements = 0;
        
        for (int i = 0; i < A.RowCount; i++)
        {
            for (int j = 0; j < A.ColumnCount; j++)
            {
                if (Math.Abs(A[i, j]) > 1e-12)
                {
                    nonZeroElements++;
                }
            }
        }
        
        return 1.0 - (double)nonZeroElements / totalElements;
    }
    
    /// <summary>
    /// 检查矩阵是否对称
    /// </summary>
    private bool IsSymmetric(Matrix<double> A)
    {
        const double tolerance = 1e-12;
        
        for (int i = 0; i < A.RowCount; i++)
        {
            for (int j = i + 1; j < A.ColumnCount; j++)
            {
                if (Math.Abs(A[i, j] - A[j, i]) > tolerance)
                {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    /// <summary>
    /// 检查矩阵是否正定
    /// </summary>
    private bool IsPositiveDefinite(Matrix<double> A)
    {
        try
        {
            // 尝试Cholesky分解，如果成功则为正定
            var cholesky = A.Cholesky();
            return cholesky != null;
        }
        catch
        {
            return false;
        }
    }
    
    /// <summary>
    /// 验证解的精度
    /// </summary>
    private async Task ValidateSolutionAsync(Matrix<double> A, Vector<double> b, Vector<double> x)
    {
        await Task.Run(() =>
        {
            var residual = b - A * x;
            var residualNorm = residual.L2Norm();
            var relativeError = residualNorm / b.L2Norm();
            
            _logger.LogDebug("解验证 - 残差范数: {ResidualNorm:E3}, 相对误差: {RelativeError:E3}",
                residualNorm, relativeError);
            
            if (relativeError > 1e-6)
            {
                _logger.LogWarning("解的精度较低，相对误差: {RelativeError:E3}", relativeError);
            }
        });
    }
}

/// <summary>
/// 求解方法枚举
/// </summary>
public enum SolverMethod
{
    DirectLU,
    DirectCholesky,
    IterativeCG,
    IterativeGMRES
}
```

## 4.3.3 应力计算与后处理

### 应力计算服务

```csharp
/// <summary>
/// 应力计算服务
/// </summary>
public class StressCalculationService
{
    private readonly ILogger<StressCalculationService> _logger;
    private readonly IElementProcessor _elementProcessor;
    
    public StressCalculationService(
        ILogger<StressCalculationService> logger,
        IElementProcessor elementProcessor)
    {
        _logger = logger;
        _elementProcessor = elementProcessor;
    }
    
    /// <summary>
    /// 计算应力和应变
    /// </summary>
    public async Task<StressCalculationResult> CalculateStressAndStrainAsync(
        AnalysisMesh analysisMesh,
        Vector<double> displacementVector,
        StressAnalysisParameters parameters)
    {
        _logger.LogInformation("开始计算应力和应变");
        
        var result = new StressCalculationResult
        {
            ElementStresses = new Dictionary<int, StressTensor>(),
            NodalStresses = new Dictionary<int, StressTensor>(),
            ElementStrains = new Dictionary<int, StrainTensor>(),
            NodalStrains = new Dictionary<int, StrainTensor>(),
            PrincipalStresses = new Dictionary<int, PrincipalStress>(),
            VonMisesStresses = new Dictionary<int, double>()
        };
        
        // 1. 计算单元应力和应变
        await CalculateElementStressesAsync(analysisMesh, displacementVector, result);
        
        // 2. 计算节点应力（平均外推）
        await CalculateNodalStressesAsync(analysisMesh, result);
        
        // 3. 计算主应力
        await CalculatePrincipalStressesAsync(result);
        
        // 4. 计算von Mises应力
        await CalculateVonMisesStressesAsync(result);
        
        // 5. 执行应力验算
        await PerformStressVerificationAsync(result, parameters);
        
        _logger.LogInformation("应力应变计算完成");
        return result;
    }
    
    /// <summary>
    /// 计算单元应力
    /// </summary>
    private async Task CalculateElementStressesAsync(
        AnalysisMesh analysisMesh,
        Vector<double> displacementVector,
        StressCalculationResult result)
    {
        await Task.Run(() =>
        {
            var mesh = analysisMesh.Mesh;
            
            Parallel.ForEach(mesh.Elements, element =>
            {
                try
                {
                    // 计算单元应力
                    var stress = _elementProcessor.CalculateElementStress(
                        element, mesh.Nodes, displacementVector);
                    
                    // 计算单元应变
                    var strain = CalculateElementStrain(element, mesh.Nodes, displacementVector);
                    
                    lock (result)
                    {
                        result.ElementStresses[element.Id] = stress;
                        result.ElementStrains[element.Id] = strain;
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "计算单元 {ElementId} 应力失败", element.Id);
                    throw;
                }
            });
        });
    }
    
    /// <summary>
    /// 计算节点应力（通过单元应力平均外推）
    /// </summary>
    private async Task CalculateNodalStressesAsync(
        AnalysisMesh analysisMesh,
        StressCalculationResult result)
    {
        await Task.Run(() =>
        {
            var mesh = analysisMesh.Mesh;
            
            foreach (var node in mesh.Nodes)
            {
                // 找到包含该节点的所有单元
                var connectedElements = mesh.Elements.Where(e => e.NodeIds.Contains(node.Id)).ToList();
                
                if (connectedElements.Count == 0) continue;
                
                // 计算应力分量的平均值
                var avgStressXX = connectedElements.Average(e => result.ElementStresses[e.Id].XX);
                var avgStressYY = connectedElements.Average(e => result.ElementStresses[e.Id].YY);
                var avgStressXY = connectedElements.Average(e => result.ElementStresses[e.Id].XY);
                var avgStressZZ = connectedElements.Average(e => result.ElementStresses[e.Id].ZZ);
                
                var avgStrainXX = connectedElements.Average(e => result.ElementStrains[e.Id].XX);
                var avgStrainYY = connectedElements.Average(e => result.ElementStrains[e.Id].YY);
                var avgStrainXY = connectedElements.Average(e => result.ElementStrains[e.Id].XY);
                var avgStrainZZ = connectedElements.Average(e => result.ElementStrains[e.Id].ZZ);
                
                result.NodalStresses[node.Id] = new StressTensor
                {
                    XX = avgStressXX,
                    YY = avgStressYY,
                    XY = avgStressXY,
                    ZZ = avgStressZZ
                };
                
                result.NodalStrains[node.Id] = new StrainTensor
                {
                    XX = avgStrainXX,
                    YY = avgStrainYY,
                    XY = avgStrainXY,
                    ZZ = avgStrainZZ
                };
            }
        });
    }
    
    /// <summary>
    /// 计算主应力
    /// </summary>
    private async Task CalculatePrincipalStressesAsync(StressCalculationResult result)
    {
        await Task.Run(() =>
        {
            foreach (var kvp in result.NodalStresses)
            {
                var stress = kvp.Value;
                var principalStress = CalculatePrincipalStress(stress);
                result.PrincipalStresses[kvp.Key] = principalStress;
            }
        });
    }
    
    /// <summary>
    /// 计算主应力
    /// </summary>
    private PrincipalStress CalculatePrincipalStress(StressTensor stress)
    {
        var sigma_x = stress.XX;
        var sigma_y = stress.YY;
        var tau_xy = stress.XY;
        
        // 主应力计算
        var sigma_avg = (sigma_x + sigma_y) / 2.0;
        var radius = Math.Sqrt(Math.Pow((sigma_x - sigma_y) / 2.0, 2) + Math.Pow(tau_xy, 2));
        
        var sigma1 = sigma_avg + radius; // 第一主应力
        var sigma2 = sigma_avg - radius; // 第二主应力
        var sigma3 = stress.ZZ;          // 第三主应力（平面应变）
        
        // 主应力方向（第一主应力）
        var theta1 = 0.5 * Math.Atan2(2 * tau_xy, sigma_x - sigma_y);
        var theta1_deg = theta1 * 180.0 / Math.PI;
        
        // 最大剪应力
        var tau_max = Math.Max(
            Math.Abs(sigma1 - sigma2) / 2.0,
            Math.Max(Math.Abs(sigma2 - sigma3) / 2.0, Math.Abs(sigma1 - sigma3) / 2.0));
        
        return new PrincipalStress
        {
            Sigma1 = sigma1,
            Sigma2 = sigma2,
            Sigma3 = sigma3,
            Direction1 = theta1_deg,
            MaxShearStress = tau_max
        };
    }
    
    /// <summary>
    /// 计算von Mises应力
    /// </summary>
    private async Task CalculateVonMisesStressesAsync(StressCalculationResult result)
    {
        await Task.Run(() =>
        {
            foreach (var kvp in result.NodalStresses)
            {
                var stress = kvp.Value;
                var vonMises = CalculateVonMisesStress(stress);
                result.VonMisesStresses[kvp.Key] = vonMises;
            }
        });
    }
    
    /// <summary>
    /// 计算von Mises应力
    /// </summary>
    private double CalculateVonMisesStress(StressTensor stress)
    {
        var sigma_x = stress.XX;
        var sigma_y = stress.YY;
        var sigma_z = stress.ZZ;
        var tau_xy = stress.XY;
        
        return Math.Sqrt(0.5 * (
            Math.Pow(sigma_x - sigma_y, 2) +
            Math.Pow(sigma_y - sigma_z, 2) +
            Math.Pow(sigma_z - sigma_x, 2) +
            6 * (Math.Pow(tau_xy, 2))));
    }
    
    /// <summary>
    /// 应力验算
    /// </summary>
    private async Task PerformStressVerificationAsync(
        StressCalculationResult result,
        StressAnalysisParameters parameters)
    {
        await Task.Run(() =>
        {
            var verification = new StressVerificationResult();
            
            // 材料强度参数
            var compressiveStrength = parameters.CompressiveStrength;
            var tensileStrength = parameters.TensileStrength;
            
            foreach (var kvp in result.PrincipalStresses)
            {
                var nodeId = kvp.Key;
                var principalStress = kvp.Value;
                
                // 抗压验算
                var compressiveRatio = Math.Abs(Math.Min(principalStress.Sigma1, principalStress.Sigma2)) / compressiveStrength;
                
                // 抗拉验算
                var tensileRatio = Math.Max(principalStress.Sigma1, principalStress.Sigma2) / tensileStrength;
                
                verification.CompressionRatios[nodeId] = compressiveRatio;
                verification.TensionRatios[nodeId] = tensileRatio;
                
                // 判断是否超限
                if (compressiveRatio > 1.0)
                {
                    verification.OverCompressedNodes.Add(nodeId);
                }
                
                if (tensileRatio > 1.0)
                {
                    verification.OverTensionNodes.Add(nodeId);
                }
            }
            
            result.Verification = verification;
        });
    }
}
```

---

## 本节小结

本节详细介绍了有限元应力计算求解器的实现，主要内容包括：

1. **求解器架构**：整体刚度矩阵组装、载荷向量处理、边界条件应用
2. **单元处理**：刚度矩阵计算、应力应变计算
3. **矩阵求解**：直接法和迭代法的选择与实现
4. **应力计算**：节点应力外推、主应力、von Mises应力

### 技术特点

- **高效算法**：针对稀疏矩阵的优化求解策略
- **并行计算**：充分利用多核处理器加速计算
- **精度控制**：多重验证确保计算精度
- **工程实用**：考虑实际工程需求的应力验算

下一节将介绍结果可视化与分析功能。
