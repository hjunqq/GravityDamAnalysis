# 4.2 有限元网格生成与处理

## 4.2.1 网格生成策略

### 网格质量要求

高质量的有限元网格是获得精确应力计算结果的前提，主要要求包括：

1. **几何要求**
   - 单元形状规整，避免过度扭曲
   - 单元尺寸过渡平缓
   - 避免锐角单元

2. **密度要求**
   - 应力梯度大的区域网格加密
   - 几何边界精确表达
   - 关键部位局部细化

3. **拓扑要求**
   - 节点连接正确
   - 无重叠单元
   - 无悬挂节点

### 网格生成算法

#### Delaunay三角剖分

Delaunay三角剖分是生成高质量三角形网格的经典算法：

```csharp
namespace GravityDamAnalysis.Meshing
{
    /// <summary>
    /// Delaunay三角剖分网格生成器
    /// </summary>
    public class DelaunayMeshGenerator
    {
        private readonly ILogger<DelaunayMeshGenerator> _logger;
        
        public DelaunayMeshGenerator(ILogger<DelaunayMeshGenerator> logger)
        {
            _logger = logger;
        }
        
        /// <summary>
        /// 生成Delaunay三角网格
        /// </summary>
        /// <param name="boundary">边界多边形</param>
        /// <param name="meshSize">网格尺寸</param>
        /// <returns>三角形网格</returns>
        public TriangularMesh GenerateDelaunayMesh(
            Polygon2D boundary, 
            double meshSize)
        {
            _logger.LogInformation("开始生成Delaunay三角网格，目标尺寸: {MeshSize}", meshSize);
            
            // 1. 边界离散化
            var boundaryPoints = DiscretizeBoundary(boundary, meshSize);
            _logger.LogDebug("边界离散化完成，点数: {PointCount}", boundaryPoints.Count);
            
            // 2. 内部点生成
            var internalPoints = GenerateInternalPoints(boundary, meshSize);
            _logger.LogDebug("内部点生成完成，点数: {PointCount}", internalPoints.Count);
            
            // 3. 合并所有点
            var allPoints = new List<Point2D>();
            allPoints.AddRange(boundaryPoints);
            allPoints.AddRange(internalPoints);
            
            // 4. 执行Delaunay三角剖分
            var triangles = DelaunayTriangulation(allPoints);
            _logger.LogDebug("Delaunay三角剖分完成，三角形数: {TriangleCount}", triangles.Count);
            
            // 5. 删除边界外的三角形
            var interiorTriangles = FilterInteriorTriangles(triangles, boundary);
            _logger.LogDebug("过滤后三角形数: {TriangleCount}", interiorTriangles.Count);
            
            // 6. 构建网格数据结构
            var mesh = BuildTriangularMesh(allPoints, interiorTriangles);
            
            _logger.LogInformation("Delaunay网格生成完成");
            return mesh;
        }
        
        /// <summary>
        /// 边界离散化
        /// </summary>
        private List<Point2D> DiscretizeBoundary(Polygon2D boundary, double meshSize)
        {
            var boundaryPoints = new List<Point2D>();
            
            foreach (var edge in boundary.Edges)
            {
                var length = edge.Length;
                var numSegments = Math.Max(1, (int)Math.Ceiling(length / meshSize));
                var segmentLength = length / numSegments;
                
                for (int i = 0; i <= numSegments; i++)
                {
                    var t = (double)i / numSegments;
                    var point = edge.Start + t * (edge.End - edge.Start);
                    
                    // 避免重复添加顶点
                    if (i < numSegments || edge == boundary.Edges.Last())
                    {
                        boundaryPoints.Add(point);
                    }
                }
            }
            
            return boundaryPoints;
        }
        
        /// <summary>
        /// 内部点生成（基于背景网格）
        /// </summary>
        private List<Point2D> GenerateInternalPoints(Polygon2D boundary, double meshSize)
        {
            var internalPoints = new List<Point2D>();
            var bbox = boundary.BoundingBox;
            
            // 计算网格行列数
            var nx = (int)Math.Ceiling((bbox.MaxX - bbox.MinX) / meshSize);
            var ny = (int)Math.Ceiling((bbox.MaxY - bbox.MinY) / meshSize);
            
            var dx = (bbox.MaxX - bbox.MinX) / nx;
            var dy = (bbox.MaxY - bbox.MinY) / ny;
            
            // 生成规则网格点
            for (int i = 1; i < nx; i++)
            {
                for (int j = 1; j < ny; j++)
                {
                    var x = bbox.MinX + i * dx;
                    var y = bbox.MinY + j * dy;
                    var point = new Point2D(x, y);
                    
                    // 检查点是否在多边形内部
                    if (boundary.ContainsPoint(point))
                    {
                        internalPoints.Add(point);
                    }
                }
            }
            
            return internalPoints;
        }
        
        /// <summary>
        /// Delaunay三角剖分（Bowyer-Watson算法）
        /// </summary>
        private List<Triangle2D> DelaunayTriangulation(List<Point2D> points)
        {
            // 创建超级三角形
            var superTriangle = CreateSuperTriangle(points);
            var triangles = new List<Triangle2D> { superTriangle };
            
            // 逐点插入
            foreach (var point in points)
            {
                var badTriangles = new List<Triangle2D>();
                var polygon = new List<Edge2D>();
                
                // 找到包含当前点的外接圆的三角形
                foreach (var triangle in triangles)
                {
                    if (triangle.CircumcircleContains(point))
                    {
                        badTriangles.Add(triangle);
                    }
                }
                
                // 提取多边形边界
                foreach (var triangle in badTriangles)
                {
                    foreach (var edge in triangle.Edges)
                    {
                        var sharedCount = badTriangles.Count(t => t.ContainsEdge(edge));
                        if (sharedCount == 1)
                        {
                            polygon.Add(edge);
                        }
                    }
                }
                
                // 删除坏三角形
                triangles.RemoveAll(badTriangles.Contains);
                
                // 添加新三角形
                foreach (var edge in polygon)
                {
                    var newTriangle = new Triangle2D(edge.Start, edge.End, point);
                    triangles.Add(newTriangle);
                }
            }
            
            // 移除包含超级三角形顶点的三角形
            triangles.RemoveAll(t => superTriangle.Vertices.Any(v => t.ContainsVertex(v)));
            
            return triangles;
        }
        
        /// <summary>
        /// 创建包含所有点的超级三角形
        /// </summary>
        private Triangle2D CreateSuperTriangle(List<Point2D> points)
        {
            var minX = points.Min(p => p.X);
            var maxX = points.Max(p => p.X);
            var minY = points.Min(p => p.Y);
            var maxY = points.Max(p => p.Y);
            
            var dx = maxX - minX;
            var dy = maxY - minY;
            var deltaMax = Math.Max(dx, dy);
            var midX = (minX + maxX) / 2;
            var midY = (minY + maxY) / 2;
            
            // 创建足够大的三角形
            var p1 = new Point2D(midX - 20 * deltaMax, midY - deltaMax);
            var p2 = new Point2D(midX, midY + 20 * deltaMax);
            var p3 = new Point2D(midX + 20 * deltaMax, midY - deltaMax);
            
            return new Triangle2D(p1, p2, p3);
        }
    }
}
```

#### 四边形网格生成

对于规则区域，四边形网格往往具有更好的数值性质：

```csharp
/// <summary>
/// 结构化四边形网格生成器
/// </summary>
public class StructuredQuadMeshGenerator
{
    /// <summary>
    /// 生成结构化四边形网格
    /// </summary>
    /// <param name="domain">计算域</param>
    /// <param name="nx">x方向单元数</param>
    /// <param name="ny">y方向单元数</param>
    /// <returns>四边形网格</returns>
    public QuadrilateralMesh GenerateStructuredMesh(
        Rectangle2D domain,
        int nx,
        int ny)
    {
        var nodes = new List<Node2D>();
        var elements = new List<QuadElement>();
        
        // 生成节点
        var dx = domain.Width / nx;
        var dy = domain.Height / ny;
        
        for (int j = 0; j <= ny; j++)
        {
            for (int i = 0; i <= nx; i++)
            {
                var x = domain.MinX + i * dx;
                var y = domain.MinY + j * dy;
                var nodeId = j * (nx + 1) + i;
                
                nodes.Add(new Node2D(nodeId, x, y));
            }
        }
        
        // 生成单元
        for (int j = 0; j < ny; j++)
        {
            for (int i = 0; i < nx; i++)
            {
                var elementId = j * nx + i;
                
                // 单元节点编号（逆时针）
                var n1 = j * (nx + 1) + i;
                var n2 = j * (nx + 1) + i + 1;
                var n3 = (j + 1) * (nx + 1) + i + 1;
                var n4 = (j + 1) * (nx + 1) + i;
                
                var element = new QuadElement(elementId, new[] { n1, n2, n3, n4 });
                elements.Add(element);
            }
        }
        
        return new QuadrilateralMesh(nodes, elements);
    }
}
```

### 网格自适应细化

对于应力集中区域，需要进行网格自适应细化：

```csharp
/// <summary>
/// 网格自适应细化器
/// </summary>
public class AdaptiveMeshRefinement
{
    /// <summary>
    /// 基于应力梯度的自适应细化
    /// </summary>
    /// <param name="mesh">原始网格</param>
    /// <param name="stressResults">应力分析结果</param>
    /// <param name="threshold">细化阈值</param>
    /// <returns>细化后的网格</returns>
    public TriangularMesh RefineBasedOnStressGradient(
        TriangularMesh mesh,
        StressAnalysisResult stressResults,
        double threshold)
    {
        var elementsToRefine = new List<int>();
        
        // 计算每个单元的应力梯度
        for (int i = 0; i < mesh.Elements.Count; i++)
        {
            var element = mesh.Elements[i];
            var stressGradient = CalculateStressGradient(element, stressResults);
            
            if (stressGradient > threshold)
            {
                elementsToRefine.Add(i);
            }
        }
        
        // 执行细化
        return RefineElements(mesh, elementsToRefine);
    }
    
    /// <summary>
    /// 计算单元应力梯度
    /// </summary>
    private double CalculateStressGradient(
        TriangleElement element,
        StressAnalysisResult stressResults)
    {
        var stresses = new List<double>();
        
        foreach (var nodeId in element.NodeIds)
        {
            var stress = stressResults.NodalStresses[nodeId];
            var vonMisesStress = CalculateVonMisesStress(stress);
            stresses.Add(vonMisesStress);
        }
        
        // 计算应力变化的最大值
        var maxStress = stresses.Max();
        var minStress = stresses.Min();
        var avgStress = stresses.Average();
        
        return Math.Abs(maxStress - minStress) / Math.Max(avgStress, 1e-10);
    }
    
    /// <summary>
    /// 计算von Mises应力
    /// </summary>
    private double CalculateVonMisesStress(StressTensor stress)
    {
        var sigma_x = stress.XX;
        var sigma_y = stress.YY;
        var tau_xy = stress.XY;
        
        return Math.Sqrt(sigma_x * sigma_x + sigma_y * sigma_y - 
                        sigma_x * sigma_y + 3 * tau_xy * tau_xy);
    }
}
```

## 4.2.2 网格数据结构

### 网格实体定义

```csharp
namespace GravityDamAnalysis.Meshing.Entities
{
    /// <summary>
    /// 二维节点
    /// </summary>
    public class Node2D
    {
        public int Id { get; set; }
        public double X { get; set; }
        public double Y { get; set; }
        public bool IsFixed { get; set; }
        public List<int> ConnectedElements { get; set; } = new();
        
        public Node2D(int id, double x, double y)
        {
            Id = id;
            X = x;
            Y = y;
        }
        
        public Point2D ToPoint2D() => new Point2D(X, Y);
    }
    
    /// <summary>
    /// 三角形单元
    /// </summary>
    public class TriangleElement
    {
        public int Id { get; set; }
        public int[] NodeIds { get; set; }
        public int MaterialId { get; set; }
        public double Thickness { get; set; } = 1.0;
        
        public TriangleElement(int id, int[] nodeIds)
        {
            Id = id;
            NodeIds = nodeIds ?? throw new ArgumentNullException(nameof(nodeIds));
            
            if (nodeIds.Length != 3)
                throw new ArgumentException("三角形单元必须有3个节点");
        }
        
        /// <summary>
        /// 计算单元面积
        /// </summary>
        public double CalculateArea(List<Node2D> nodes)
        {
            var n1 = nodes.First(n => n.Id == NodeIds[0]);
            var n2 = nodes.First(n => n.Id == NodeIds[1]);
            var n3 = nodes.First(n => n.Id == NodeIds[2]);
            
            return 0.5 * Math.Abs(
                (n2.X - n1.X) * (n3.Y - n1.Y) - (n3.X - n1.X) * (n2.Y - n1.Y));
        }
        
        /// <summary>
        /// 计算单元重心
        /// </summary>
        public Point2D CalculateCentroid(List<Node2D> nodes)
        {
            var n1 = nodes.First(n => n.Id == NodeIds[0]);
            var n2 = nodes.First(n => n.Id == NodeIds[1]);
            var n3 = nodes.First(n => n.Id == NodeIds[2]);
            
            var x = (n1.X + n2.X + n3.X) / 3.0;
            var y = (n1.Y + n2.Y + n3.Y) / 3.0;
            
            return new Point2D(x, y);
        }
    }
    
    /// <summary>
    /// 四边形单元
    /// </summary>
    public class QuadElement
    {
        public int Id { get; set; }
        public int[] NodeIds { get; set; }
        public int MaterialId { get; set; }
        public double Thickness { get; set; } = 1.0;
        
        public QuadElement(int id, int[] nodeIds)
        {
            Id = id;
            NodeIds = nodeIds ?? throw new ArgumentNullException(nameof(nodeIds));
            
            if (nodeIds.Length != 4)
                throw new ArgumentException("四边形单元必须有4个节点");
        }
        
        /// <summary>
        /// 计算单元面积
        /// </summary>
        public double CalculateArea(List<Node2D> nodes)
        {
            var n1 = nodes.First(n => n.Id == NodeIds[0]);
            var n2 = nodes.First(n => n.Id == NodeIds[1]);
            var n3 = nodes.First(n => n.Id == NodeIds[2]);
            var n4 = nodes.First(n => n.Id == NodeIds[3]);
            
            // 使用Shoelace公式计算四边形面积
            var area = 0.5 * Math.Abs(
                (n1.X * n2.Y - n2.X * n1.Y) +
                (n2.X * n3.Y - n3.X * n2.Y) +
                (n3.X * n4.Y - n4.X * n3.Y) +
                (n4.X * n1.Y - n1.X * n4.Y));
            
            return area;
        }
    }
    
    /// <summary>
    /// 三角形网格
    /// </summary>
    public class TriangularMesh
    {
        public List<Node2D> Nodes { get; set; }
        public List<TriangleElement> Elements { get; set; }
        public List<BoundaryEdge> BoundaryEdges { get; set; }
        
        public TriangularMesh()
        {
            Nodes = new List<Node2D>();
            Elements = new List<TriangleElement>();
            BoundaryEdges = new List<BoundaryEdge>();
        }
        
        /// <summary>
        /// 网格质量统计
        /// </summary>
        public MeshQualityStats GetQualityStats()
        {
            var stats = new MeshQualityStats();
            
            foreach (var element in Elements)
            {
                var area = element.CalculateArea(Nodes);
                var aspectRatio = CalculateAspectRatio(element);
                var skewness = CalculateSkewness(element);
                
                stats.MinArea = Math.Min(stats.MinArea, area);
                stats.MaxArea = Math.Max(stats.MaxArea, area);
                stats.MinAspectRatio = Math.Min(stats.MinAspectRatio, aspectRatio);
                stats.MaxAspectRatio = Math.Max(stats.MaxAspectRatio, aspectRatio);
                stats.MaxSkewness = Math.Max(stats.MaxSkewness, skewness);
            }
            
            stats.AverageArea = Elements.Average(e => e.CalculateArea(Nodes));
            stats.TotalElements = Elements.Count;
            stats.TotalNodes = Nodes.Count;
            
            return stats;
        }
        
        private double CalculateAspectRatio(TriangleElement element)
        {
            // 计算三角形的纵横比
            var n1 = Nodes.First(n => n.Id == element.NodeIds[0]);
            var n2 = Nodes.First(n => n.Id == element.NodeIds[1]);
            var n3 = Nodes.First(n => n.Id == element.NodeIds[2]);
            
            var a = Distance(n1, n2);
            var b = Distance(n2, n3);
            var c = Distance(n3, n1);
            
            var maxEdge = Math.Max(Math.Max(a, b), c);
            var minEdge = Math.Min(Math.Min(a, b), c);
            
            return maxEdge / minEdge;
        }
        
        private double CalculateSkewness(TriangleElement element)
        {
            // 计算三角形的歪斜度
            var area = element.CalculateArea(Nodes);
            
            var n1 = Nodes.First(n => n.Id == element.NodeIds[0]);
            var n2 = Nodes.First(n => n.Id == element.NodeIds[1]);
            var n3 = Nodes.First(n => n.Id == element.NodeIds[2]);
            
            var a = Distance(n1, n2);
            var b = Distance(n2, n3);
            var c = Distance(n3, n1);
            
            var s = (a + b + c) / 2; // 半周长
            var idealArea = Math.Sqrt(s * (s - a) * (s - b) * (s - c)); // 理想面积
            
            return Math.Abs(area - idealArea) / idealArea;
        }
        
        private double Distance(Node2D n1, Node2D n2)
        {
            return Math.Sqrt((n1.X - n2.X) * (n1.X - n2.X) + (n1.Y - n2.Y) * (n1.Y - n2.Y));
        }
    }
    
    /// <summary>
    /// 边界边
    /// </summary>
    public class BoundaryEdge
    {
        public int StartNodeId { get; set; }
        public int EndNodeId { get; set; }
        public BoundaryType Type { get; set; }
        public double LoadValue { get; set; }
        
        public BoundaryEdge(int startNodeId, int endNodeId, BoundaryType type)
        {
            StartNodeId = startNodeId;
            EndNodeId = endNodeId;
            Type = type;
        }
    }
    
    /// <summary>
    /// 边界类型
    /// </summary>
    public enum BoundaryType
    {
        Fixed,          // 固定约束
        Roller,         // 滚动约束
        Force,          // 集中力
        Pressure,       // 分布压力
        Free            // 自由边界
    }
    
    /// <summary>
    /// 网格质量统计
    /// </summary>
    public class MeshQualityStats
    {
        public int TotalNodes { get; set; }
        public int TotalElements { get; set; }
        public double MinArea { get; set; } = double.MaxValue;
        public double MaxArea { get; set; } = double.MinValue;
        public double AverageArea { get; set; }
        public double MinAspectRatio { get; set; } = double.MaxValue;
        public double MaxAspectRatio { get; set; } = double.MinValue;
        public double MaxSkewness { get; set; } = double.MinValue;
        
        public override string ToString()
        {
            return $"节点数: {TotalNodes}, 单元数: {TotalElements}, " +
                   $"面积范围: [{MinArea:F3}, {MaxArea:F3}], " +
                   $"纵横比范围: [{MinAspectRatio:F2}, {MaxAspectRatio:F2}], " +
                   $"最大歪斜度: {MaxSkewness:F3}";
        }
    }
}
```

## 4.2.3 Revit几何到网格的转换

### 几何提取服务

```csharp
namespace GravityDamAnalysis.Revit.Meshing
{
    /// <summary>
    /// Revit几何到网格转换服务
    /// </summary>
    public class RevitToMeshConverter
    {
        private readonly ILogger<RevitToMeshConverter> _logger;
        private readonly IDamGeometryExtractor _geometryExtractor;
        
        public RevitToMeshConverter(
            ILogger<RevitToMeshConverter> logger,
            IDamGeometryExtractor geometryExtractor)
        {
            _logger = logger;
            _geometryExtractor = geometryExtractor;
        }
        
        /// <summary>
        /// 从Revit元素生成分析网格
        /// </summary>
        /// <param name="damElementId">坝体元素ID</param>
        /// <param name="meshParameters">网格参数</param>
        /// <returns>分析网格</returns>
        public async Task<AnalysisMesh> ConvertToAnalysisMeshAsync(
            ElementId damElementId,
            MeshGenerationParameters meshParameters)
        {
            _logger.LogInformation("开始从Revit元素生成分析网格，ElementId: {ElementId}", damElementId);
            
            // 1. 提取坝体几何
            var damGeometry = await _geometryExtractor.ExtractDamGeometryAsync(damElementId);
            _logger.LogDebug("坝体几何提取完成");
            
            // 2. 获取2D剖面
            var profile2D = await _geometryExtractor.ExtractProfile2DAsync(damElementId);
            _logger.LogDebug("2D剖面提取完成，轮廓点数: {PointCount}", profile2D.ContourPoints.Count);
            
            // 3. 生成分析网格
            var mesh = await GenerateAnalysisMeshAsync(profile2D, meshParameters);
            _logger.LogDebug("网格生成完成，节点数: {NodeCount}, 单元数: {ElementCount}", 
                mesh.Nodes.Count, mesh.Elements.Count);
            
            // 4. 应用边界条件
            ApplyBoundaryConditions(mesh, damGeometry, meshParameters);
            _logger.LogDebug("边界条件应用完成");
            
            // 5. 验证网格质量
            var qualityStats = mesh.GetQualityStats();
            _logger.LogInformation("网格质量统计: {QualityStats}", qualityStats);
            
            // 6. 创建分析网格对象
            var analysisMesh = new AnalysisMesh
            {
                Mesh = mesh,
                DamGeometry = damGeometry,
                Profile2D = profile2D,
                Parameters = meshParameters,
                QualityStats = qualityStats,
                GeneratedAt = DateTime.UtcNow
            };
            
            _logger.LogInformation("分析网格生成完成");
            return analysisMesh;
        }
        
        /// <summary>
        /// 生成分析网格
        /// </summary>
        private async Task<TriangularMesh> GenerateAnalysisMeshAsync(
            Profile2D profile2D,
            MeshGenerationParameters parameters)
        {
            // 创建边界多边形
            var boundary = CreateBoundaryPolygon(profile2D);
            
            // 根据网格类型选择生成器
            switch (parameters.MeshType)
            {
                case MeshType.Delaunay:
                    var delaunayGenerator = new DelaunayMeshGenerator(_logger);
                    return delaunayGenerator.GenerateDelaunayMesh(boundary, parameters.ElementSize);
                
                case MeshType.Advancing Front:
                    var frontGenerator = new AdvancingFrontMeshGenerator(_logger);
                    return await frontGenerator.GenerateMeshAsync(boundary, parameters);
                
                default:
                    throw new NotSupportedException($"不支持的网格类型: {parameters.MeshType}");
            }
        }
        
        /// <summary>
        /// 创建边界多边形
        /// </summary>
        private Polygon2D CreateBoundaryPolygon(Profile2D profile2D)
        {
            var boundaryPoints = profile2D.ContourPoints
                .Select(p => new Point2D(p.X, p.Y))
                .ToList();
            
            // 确保多边形闭合
            if (!boundaryPoints.First().Equals(boundaryPoints.Last()))
            {
                boundaryPoints.Add(boundaryPoints.First());
            }
            
            return new Polygon2D(boundaryPoints);
        }
        
        /// <summary>
        /// 应用边界条件
        /// </summary>
        private void ApplyBoundaryConditions(
            TriangularMesh mesh,
            DamGeometry damGeometry,
            MeshGenerationParameters parameters)
        {
            var tolerance = parameters.BoundaryTolerance;
            
            foreach (var node in mesh.Nodes)
            {
                var point = new Point3D(node.X, node.Y, 0);
                
                // 判断节点位置并设置边界条件
                if (IsOnDamBase(point, damGeometry, tolerance))
                {
                    // 坝基固定约束
                    var boundaryEdge = new BoundaryEdge(node.Id, node.Id, BoundaryType.Fixed);
                    mesh.BoundaryEdges.Add(boundaryEdge);
                    node.IsFixed = true;
                }
                else if (IsOnUpstreamFace(point, damGeometry, tolerance))
                {
                    // 上游面水压力
                    var waterPressure = CalculateWaterPressure(point, parameters.UpstreamWaterLevel);
                    var boundaryEdge = new BoundaryEdge(node.Id, node.Id, BoundaryType.Pressure)
                    {
                        LoadValue = waterPressure
                    };
                    mesh.BoundaryEdges.Add(boundaryEdge);
                }
            }
        }
        
        /// <summary>
        /// 判断点是否在坝基上
        /// </summary>
        private bool IsOnDamBase(Point3D point, DamGeometry geometry, double tolerance)
        {
            return Math.Abs(point.Y - geometry.BaseElevation) < tolerance;
        }
        
        /// <summary>
        /// 判断点是否在上游面上
        /// </summary>
        private bool IsOnUpstreamFace(Point3D point, DamGeometry geometry, double tolerance)
        {
            // 简化处理，实际应该根据具体的几何形状判断
            return point.X < (geometry.CenterX - geometry.BaseWidth / 4);
        }
        
        /// <summary>
        /// 计算水压力
        /// </summary>
        private double CalculateWaterPressure(Point3D point, double waterLevel)
        {
            var waterDepth = waterLevel - point.Y;
            return waterDepth > 0 ? 9.8 * waterDepth : 0; // γw * h
        }
    }
    
    /// <summary>
    /// 网格生成参数
    /// </summary>
    public class MeshGenerationParameters
    {
        public MeshType MeshType { get; set; } = MeshType.Delaunay;
        public double ElementSize { get; set; } = 2.0;
        public double BoundaryTolerance { get; set; } = 0.1;
        public double UpstreamWaterLevel { get; set; }
        public double DownstreamWaterLevel { get; set; }
        public bool EnableRefinement { get; set; } = true;
        public double RefinementRatio { get; set; } = 0.5;
        public List<RefinementZone> RefinementZones { get; set; } = new();
    }
    
    /// <summary>
    /// 网格类型
    /// </summary>
    public enum MeshType
    {
        Delaunay,
        AdvancingFront,
        Structured
    }
    
    /// <summary>
    /// 细化区域
    /// </summary>
    public class RefinementZone
    {
        public string Name { get; set; }
        public Polygon2D Region { get; set; }
        public double ElementSize { get; set; }
        public string Reason { get; set; }
    }
    
    /// <summary>
    /// 分析网格
    /// </summary>
    public class AnalysisMesh
    {
        public TriangularMesh Mesh { get; set; }
        public DamGeometry DamGeometry { get; set; }
        public Profile2D Profile2D { get; set; }
        public MeshGenerationParameters Parameters { get; set; }
        public MeshQualityStats QualityStats { get; set; }
        public DateTime GeneratedAt { get; set; }
        
        /// <summary>
        /// 导出到分析软件格式
        /// </summary>
        public void ExportToFile(string filePath, MeshFormat format)
        {
            switch (format)
            {
                case MeshFormat.Ansys:
                    ExportToAnsysFormat(filePath);
                    break;
                case MeshFormat.Abaqus:
                    ExportToAbaqusFormat(filePath);
                    break;
                case MeshFormat.Nastran:
                    ExportToNastranFormat(filePath);
                    break;
                default:
                    throw new NotSupportedException($"不支持的网格格式: {format}");
            }
        }
        
        private void ExportToAnsysFormat(string filePath)
        {
            using var writer = new StreamWriter(filePath);
            
            // 写入节点
            writer.WriteLine("! Nodes");
            foreach (var node in Mesh.Nodes)
            {
                writer.WriteLine($"N,{node.Id},{node.X:F6},{node.Y:F6},0");
            }
            
            // 写入单元
            writer.WriteLine("! Elements");
            writer.WriteLine("ET,1,PLANE183");
            foreach (var element in Mesh.Elements)
            {
                writer.WriteLine($"E,{element.NodeIds[0]},{element.NodeIds[1]},{element.NodeIds[2]}");
            }
            
            // 写入材料属性
            writer.WriteLine("! Material Properties");
            writer.WriteLine("MP,EX,1,30000E6");
            writer.WriteLine("MP,PRXY,1,0.2");
            writer.WriteLine("MP,DENS,1,2400");
        }
    }
    
    /// <summary>
    /// 网格导出格式
    /// </summary>
    public enum MeshFormat
    {
        Ansys,
        Abaqus,
        Nastran,
        Gmsh
    }
}
```

## 4.2.4 网格质量控制

### 网格质量检查器

```csharp
/// <summary>
/// 网格质量检查和优化器
/// </summary>
public class MeshQualityController
{
    private readonly ILogger<MeshQualityController> _logger;
    
    public MeshQualityController(ILogger<MeshQualityController> logger)
    {
        _logger = logger;
    }
    
    /// <summary>
    /// 执行网格质量检查
    /// </summary>
    /// <param name="mesh">待检查的网格</param>
    /// <returns>质量检查结果</returns>
    public MeshQualityReport CheckMeshQuality(TriangularMesh mesh)
    {
        _logger.LogInformation("开始网格质量检查");
        
        var report = new MeshQualityReport
        {
            TotalElements = mesh.Elements.Count,
            TotalNodes = mesh.Nodes.Count,
            CheckedAt = DateTime.UtcNow
        };
        
        // 1. 几何质量检查
        CheckGeometricQuality(mesh, report);
        
        // 2. 拓扑质量检查
        CheckTopologicalQuality(mesh, report);
        
        // 3. 数值质量检查
        CheckNumericalQuality(mesh, report);
        
        // 4. 生成质量等级
        DetermineQualityLevel(report);
        
        _logger.LogInformation("网格质量检查完成，质量等级: {QualityLevel}", report.QualityLevel);
        return report;
    }
    
    /// <summary>
    /// 几何质量检查
    /// </summary>
    private void CheckGeometricQuality(TriangularMesh mesh, MeshQualityReport report)
    {
        var aspectRatios = new List<double>();
        var areas = new List<double>();
        var angles = new List<double>();
        
        foreach (var element in mesh.Elements)
        {
            var nodes = element.NodeIds.Select(id => mesh.Nodes.First(n => n.Id == id)).ToArray();
            
            // 计算面积
            var area = CalculateTriangleArea(nodes);
            areas.Add(area);
            
            // 计算纵横比
            var aspectRatio = CalculateAspectRatio(nodes);
            aspectRatios.Add(aspectRatio);
            
            // 计算内角
            var elementAngles = CalculateTriangleAngles(nodes);
            angles.AddRange(elementAngles);
        }
        
        // 统计几何质量指标
        report.MinArea = areas.Min();
        report.MaxArea = areas.Max();
        report.AverageArea = areas.Average();
        
        report.MinAspectRatio = aspectRatios.Min();
        report.MaxAspectRatio = aspectRatios.Max();
        report.AverageAspectRatio = aspectRatios.Average();
        
        report.MinAngle = angles.Min();
        report.MaxAngle = angles.Max();
        
        // 质量问题统计
        report.DistortedElements = aspectRatios.Count(r => r > 10.0);
        report.SliverElements = angles.Count(a => a < 5.0 || a > 175.0);
    }
    
    /// <summary>
    /// 拓扑质量检查
    /// </summary>
    private void CheckTopologicalQuality(TriangularMesh mesh, MeshQualityReport report)
    {
        // 检查重复节点
        var duplicateNodes = FindDuplicateNodes(mesh);
        report.DuplicateNodes = duplicateNodes.Count;
        
        // 检查重叠单元
        var overlappingElements = FindOverlappingElements(mesh);
        report.OverlappingElements = overlappingElements.Count;
        
        // 检查悬挂节点
        var hangingNodes = FindHangingNodes(mesh);
        report.HangingNodes = hangingNodes.Count;
        
        // 检查连通性
        var connectivity = CheckConnectivity(mesh);
        report.IsConnected = connectivity.IsFullyConnected;
        report.ConnectedComponents = connectivity.ComponentCount;
    }
    
    /// <summary>
    /// 数值质量检查
    /// </summary>
    private void CheckNumericalQuality(TriangularMesh mesh, MeshQualityReport report)
    {
        var conditionNumbers = new List<double>();
        
        foreach (var element in mesh.Elements)
        {
            // 计算单元刚度矩阵的条件数
            var conditionNumber = CalculateElementConditionNumber(element, mesh.Nodes);
            conditionNumbers.Add(conditionNumber);
        }
        
        report.MinConditionNumber = conditionNumbers.Min();
        report.MaxConditionNumber = conditionNumbers.Max();
        report.AverageConditionNumber = conditionNumbers.Average();
        
        // 病态单元统计
        report.IllConditionedElements = conditionNumbers.Count(c => c > 1e12);
    }
    
    /// <summary>
    /// 网格优化
    /// </summary>
    public TriangularMesh OptimizeMesh(TriangularMesh mesh, MeshQualityReport qualityReport)
    {
        _logger.LogInformation("开始网格优化");
        
        var optimizedMesh = mesh.DeepCopy();
        
        // 1. 节点位置优化（Laplacian smoothing）
        if (qualityReport.AverageAspectRatio > 5.0)
        {
            optimizedMesh = ApplyLaplacianSmoothing(optimizedMesh);
            _logger.LogDebug("应用拉普拉斯平滑");
        }
        
        // 2. 边界交换优化
        if (qualityReport.SliverElements > 0)
        {
            optimizedMesh = ApplyEdgeSwapping(optimizedMesh);
            _logger.LogDebug("应用边界交换优化");
        }
        
        // 3. 局部细化
        if (qualityReport.IllConditionedElements > 0)
        {
            optimizedMesh = ApplyLocalRefinement(optimizedMesh, qualityReport);
            _logger.LogDebug("应用局部细化");
        }
        
        _logger.LogInformation("网格优化完成");
        return optimizedMesh;
    }
    
    /// <summary>
    /// 拉普拉斯平滑
    /// </summary>
    private TriangularMesh ApplyLaplacianSmoothing(TriangularMesh mesh)
    {
        var smoothedMesh = mesh.DeepCopy();
        const int iterations = 5;
        const double relaxationFactor = 0.5;
        
        for (int iter = 0; iter < iterations; iter++)
        {
            foreach (var node in smoothedMesh.Nodes.Where(n => !n.IsFixed))
            {
                var neighbors = FindNeighborNodes(node, smoothedMesh);
                if (neighbors.Count == 0) continue;
                
                var avgX = neighbors.Average(n => n.X);
                var avgY = neighbors.Average(n => n.Y);
                
                // 应用松弛因子
                node.X += relaxationFactor * (avgX - node.X);
                node.Y += relaxationFactor * (avgY - node.Y);
            }
        }
        
        return smoothedMesh;
    }
    
    private List<Node2D> FindNeighborNodes(Node2D node, TriangularMesh mesh)
    {
        var neighbors = new List<Node2D>();
        var connectedElements = mesh.Elements.Where(e => e.NodeIds.Contains(node.Id));
        
        foreach (var element in connectedElements)
        {
            foreach (var nodeId in element.NodeIds)
            {
                if (nodeId != node.Id)
                {
                    var neighbor = mesh.Nodes.First(n => n.Id == nodeId);
                    if (!neighbors.Contains(neighbor))
                    {
                        neighbors.Add(neighbor);
                    }
                }
            }
        }
        
        return neighbors;
    }
}

/// <summary>
/// 网格质量报告
/// </summary>
public class MeshQualityReport
{
    public int TotalNodes { get; set; }
    public int TotalElements { get; set; }
    public DateTime CheckedAt { get; set; }
    
    // 几何质量指标
    public double MinArea { get; set; }
    public double MaxArea { get; set; }
    public double AverageArea { get; set; }
    public double MinAspectRatio { get; set; }
    public double MaxAspectRatio { get; set; }
    public double AverageAspectRatio { get; set; }
    public double MinAngle { get; set; }
    public double MaxAngle { get; set; }
    
    // 拓扑质量指标
    public int DuplicateNodes { get; set; }
    public int OverlappingElements { get; set; }
    public int HangingNodes { get; set; }
    public bool IsConnected { get; set; }
    public int ConnectedComponents { get; set; }
    
    // 数值质量指标
    public double MinConditionNumber { get; set; }
    public double MaxConditionNumber { get; set; }
    public double AverageConditionNumber { get; set; }
    
    // 问题统计
    public int DistortedElements { get; set; }
    public int SliverElements { get; set; }
    public int IllConditionedElements { get; set; }
    
    // 总体质量等级
    public MeshQualityLevel QualityLevel { get; set; }
    
    public string GenerateReport()
    {
        var sb = new StringBuilder();
        sb.AppendLine("网格质量检查报告");
        sb.AppendLine("==================");
        sb.AppendLine($"检查时间: {CheckedAt:yyyy-MM-dd HH:mm:ss}");
        sb.AppendLine($"总体质量等级: {QualityLevel}");
        sb.AppendLine();
        
        sb.AppendLine("基本统计:");
        sb.AppendLine($"  节点数: {TotalNodes}");
        sb.AppendLine($"  单元数: {TotalElements}");
        sb.AppendLine();
        
        sb.AppendLine("几何质量:");
        sb.AppendLine($"  面积范围: [{MinArea:F3}, {MaxArea:F3}]");
        sb.AppendLine($"  纵横比范围: [{MinAspectRatio:F2}, {MaxAspectRatio:F2}]");
        sb.AppendLine($"  角度范围: [{MinAngle:F1}°, {MaxAngle:F1}°]");
        sb.AppendLine();
        
        sb.AppendLine("拓扑质量:");
        sb.AppendLine($"  重复节点: {DuplicateNodes}");
        sb.AppendLine($"  重叠单元: {OverlappingElements}");
        sb.AppendLine($"  悬挂节点: {HangingNodes}");
        sb.AppendLine($"  连通性: {(IsConnected ? "完全连通" : $"{ConnectedComponents}个连通分量")}");
        sb.AppendLine();
        
        sb.AppendLine("数值质量:");
        sb.AppendLine($"  条件数范围: [{MinConditionNumber:E2}, {MaxConditionNumber:E2}]");
        sb.AppendLine($"  病态单元: {IllConditionedElements}");
        sb.AppendLine();
        
        sb.AppendLine("问题诊断:");
        sb.AppendLine($"  扭曲单元: {DistortedElements}");
        sb.AppendLine($"  细长单元: {SliverElements}");
        
        return sb.ToString();
    }
}

/// <summary>
/// 网格质量等级
/// </summary>
public enum MeshQualityLevel
{
    Excellent,   // 优秀
    Good,        // 良好
    Acceptable,  // 可接受
    Poor,        // 较差
    Unacceptable // 不可接受
}
```

---

## 本节小结

本节详细介绍了有限元网格生成与处理技术，主要内容包括：

1. **网格生成策略**：Delaunay三角剖分、结构化网格、自适应细化
2. **网格数据结构**：节点、单元、边界条件的数据组织
3. **Revit集成**：从BIM模型到分析网格的转换流程
4. **质量控制**：网格质量检查、优化和验证方法

### 关键技术要点

- **高质量网格**：保证数值计算的精度和稳定性
- **自动化处理**：从BIM模型自动生成分析网格
- **质量控制**：多层次的质量检查和优化机制
- **格式兼容**：支持多种有限元软件格式导出

下一节将介绍应力计算求解器的实现。
